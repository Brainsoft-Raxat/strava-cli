// Package client provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package client

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
)

// Defines values for GetActivityStreamsParamsKeys.
const (
	Altitude       GetActivityStreamsParamsKeys = "altitude"
	Cadence        GetActivityStreamsParamsKeys = "cadence"
	Distance       GetActivityStreamsParamsKeys = "distance"
	GradeSmooth    GetActivityStreamsParamsKeys = "grade_smooth"
	Heartrate      GetActivityStreamsParamsKeys = "heartrate"
	Latlng         GetActivityStreamsParamsKeys = "latlng"
	Moving         GetActivityStreamsParamsKeys = "moving"
	Temp           GetActivityStreamsParamsKeys = "temp"
	Time           GetActivityStreamsParamsKeys = "time"
	VelocitySmooth GetActivityStreamsParamsKeys = "velocity_smooth"
	Watts          GetActivityStreamsParamsKeys = "watts"
)

// Defines values for ExploreSegmentsParamsActivityType.
const (
	Riding  ExploreSegmentsParamsActivityType = "riding"
	Running ExploreSegmentsParamsActivityType = "running"
)

// GetActivityByIdParams defines parameters for GetActivityById.
type GetActivityByIdParams struct {
	// IncludeAllEfforts To include all segments efforts.
	IncludeAllEfforts *bool `form:"include_all_efforts,omitempty" json:"include_all_efforts,omitempty"`
}

// GetCommentsByActivityIdParams defines parameters for GetCommentsByActivityId.
type GetCommentsByActivityIdParams struct {
	// Page Deprecated. Prefer to use after_cursor.
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Deprecated. Prefer to use page_size.
	PerPage *int `form:"per_page,omitempty" json:"per_page,omitempty"`

	// PageSize Number of items per page. Defaults to 30.
	PageSize *int `form:"page_size,omitempty" json:"page_size,omitempty"`

	// AfterCursor Cursor of the last item in the previous page of results, used to request the subsequent page of results.  When omitted, the first page of results is fetched.
	AfterCursor *string `form:"after_cursor,omitempty" json:"after_cursor,omitempty"`
}

// GetKudoersByActivityIdParams defines parameters for GetKudoersByActivityId.
type GetKudoersByActivityIdParams struct {
	// Page Page number. Defaults to 1.
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Number of items per page. Defaults to 30.
	PerPage *int `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// GetActivityStreamsParams defines parameters for GetActivityStreams.
type GetActivityStreamsParams struct {
	// Keys Desired stream types.
	Keys []GetActivityStreamsParamsKeys `form:"keys" json:"keys"`

	// KeyByType Must be true.
	KeyByType bool `form:"key_by_type" json:"key_by_type"`
}

// GetActivityStreamsParamsKeys defines parameters for GetActivityStreams.
type GetActivityStreamsParamsKeys string

// GetLoggedInAthleteActivitiesParams defines parameters for GetLoggedInAthleteActivities.
type GetLoggedInAthleteActivitiesParams struct {
	// Before An epoch timestamp to use for filtering activities that have taken place before a certain time.
	Before *int `form:"before,omitempty" json:"before,omitempty"`

	// After An epoch timestamp to use for filtering activities that have taken place after a certain time.
	After *int `form:"after,omitempty" json:"after,omitempty"`

	// Page Page number. Defaults to 1.
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Number of items per page. Defaults to 30.
	PerPage *int `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// GetLoggedInAthleteClubsParams defines parameters for GetLoggedInAthleteClubs.
type GetLoggedInAthleteClubsParams struct {
	// Page Page number. Defaults to 1.
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Number of items per page. Defaults to 30.
	PerPage *int `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// GetRoutesByAthleteIdParams defines parameters for GetRoutesByAthleteId.
type GetRoutesByAthleteIdParams struct {
	// Page Page number. Defaults to 1.
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Number of items per page. Defaults to 30.
	PerPage *int `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// GetClubActivitiesByIdParams defines parameters for GetClubActivitiesById.
type GetClubActivitiesByIdParams struct {
	// Page Page number. Defaults to 1.
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Number of items per page. Defaults to 30.
	PerPage *int `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// GetClubMembersByIdParams defines parameters for GetClubMembersById.
type GetClubMembersByIdParams struct {
	// Page Page number. Defaults to 1.
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Number of items per page. Defaults to 30.
	PerPage *int `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// GetEffortsBySegmentIdParams defines parameters for GetEffortsBySegmentId.
type GetEffortsBySegmentIdParams struct {
	// SegmentId The identifier of the segment.
	SegmentId int `form:"segment_id" json:"segment_id"`

	// StartDateLocal ISO 8601 formatted date time.
	StartDateLocal *time.Time `form:"start_date_local,omitempty" json:"start_date_local,omitempty"`

	// EndDateLocal ISO 8601 formatted date time.
	EndDateLocal *time.Time `form:"end_date_local,omitempty" json:"end_date_local,omitempty"`

	// PerPage Number of items per page. Defaults to 30.
	PerPage *int `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// ExploreSegmentsParams defines parameters for ExploreSegments.
type ExploreSegmentsParams struct {
	// Bounds The latitude and longitude for two points describing a rectangular boundary for the search: [southwest corner latitutde, southwest corner longitude, northeast corner latitude, northeast corner longitude]
	Bounds []float32 `form:"bounds" json:"bounds"`

	// ActivityType Desired activity type.
	ActivityType *ExploreSegmentsParamsActivityType `form:"activity_type,omitempty" json:"activity_type,omitempty"`

	// MinCat The minimum climbing category.
	MinCat *int `form:"min_cat,omitempty" json:"min_cat,omitempty"`

	// MaxCat The maximum climbing category.
	MaxCat *int `form:"max_cat,omitempty" json:"max_cat,omitempty"`
}

// ExploreSegmentsParamsActivityType defines parameters for ExploreSegments.
type ExploreSegmentsParamsActivityType string

// GetLoggedInAthleteStarredSegmentsParams defines parameters for GetLoggedInAthleteStarredSegments.
type GetLoggedInAthleteStarredSegmentsParams struct {
	// Page Page number. Defaults to 1.
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// PerPage Number of items per page. Defaults to 30.
	PerPage *int `form:"per_page,omitempty" json:"per_page,omitempty"`
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetActivityById request
	GetActivityById(ctx context.Context, id int64, params *GetActivityByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCommentsByActivityId request
	GetCommentsByActivityId(ctx context.Context, id int64, params *GetCommentsByActivityIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetKudoersByActivityId request
	GetKudoersByActivityId(ctx context.Context, id int64, params *GetKudoersByActivityIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLapsByActivityId request
	GetLapsByActivityId(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetActivityStreams request
	GetActivityStreams(ctx context.Context, id int64, params *GetActivityStreamsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetZonesByActivityId request
	GetZonesByActivityId(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLoggedInAthlete request
	GetLoggedInAthlete(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLoggedInAthleteActivities request
	GetLoggedInAthleteActivities(ctx context.Context, params *GetLoggedInAthleteActivitiesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLoggedInAthleteClubs request
	GetLoggedInAthleteClubs(ctx context.Context, params *GetLoggedInAthleteClubsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLoggedInAthleteZones request
	GetLoggedInAthleteZones(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRoutesByAthleteId request
	GetRoutesByAthleteId(ctx context.Context, id int64, params *GetRoutesByAthleteIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStats request
	GetStats(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetClubById request
	GetClubById(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetClubActivitiesById request
	GetClubActivitiesById(ctx context.Context, id int64, params *GetClubActivitiesByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetClubMembersById request
	GetClubMembersById(ctx context.Context, id int64, params *GetClubMembersByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGearById request
	GetGearById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRouteById request
	GetRouteById(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEffortsBySegmentId request
	GetEffortsBySegmentId(ctx context.Context, params *GetEffortsBySegmentIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSegmentEffortById request
	GetSegmentEffortById(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExploreSegments request
	ExploreSegments(ctx context.Context, params *ExploreSegmentsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLoggedInAthleteStarredSegments request
	GetLoggedInAthleteStarredSegments(ctx context.Context, params *GetLoggedInAthleteStarredSegmentsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSegmentById request
	GetSegmentById(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetActivityById(ctx context.Context, id int64, params *GetActivityByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetActivityByIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCommentsByActivityId(ctx context.Context, id int64, params *GetCommentsByActivityIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCommentsByActivityIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetKudoersByActivityId(ctx context.Context, id int64, params *GetKudoersByActivityIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetKudoersByActivityIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLapsByActivityId(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLapsByActivityIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetActivityStreams(ctx context.Context, id int64, params *GetActivityStreamsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetActivityStreamsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetZonesByActivityId(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetZonesByActivityIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLoggedInAthlete(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLoggedInAthleteRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLoggedInAthleteActivities(ctx context.Context, params *GetLoggedInAthleteActivitiesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLoggedInAthleteActivitiesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLoggedInAthleteClubs(ctx context.Context, params *GetLoggedInAthleteClubsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLoggedInAthleteClubsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLoggedInAthleteZones(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLoggedInAthleteZonesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRoutesByAthleteId(ctx context.Context, id int64, params *GetRoutesByAthleteIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRoutesByAthleteIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStats(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStatsRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetClubById(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClubByIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetClubActivitiesById(ctx context.Context, id int64, params *GetClubActivitiesByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClubActivitiesByIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetClubMembersById(ctx context.Context, id int64, params *GetClubMembersByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClubMembersByIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGearById(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGearByIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRouteById(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRouteByIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEffortsBySegmentId(ctx context.Context, params *GetEffortsBySegmentIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEffortsBySegmentIdRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSegmentEffortById(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSegmentEffortByIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExploreSegments(ctx context.Context, params *ExploreSegmentsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExploreSegmentsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLoggedInAthleteStarredSegments(ctx context.Context, params *GetLoggedInAthleteStarredSegmentsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLoggedInAthleteStarredSegmentsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSegmentById(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSegmentByIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetActivityByIdRequest generates requests for GetActivityById
func NewGetActivityByIdRequest(server string, id int64, params *GetActivityByIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/activities/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IncludeAllEfforts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_all_efforts", runtime.ParamLocationQuery, *params.IncludeAllEfforts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCommentsByActivityIdRequest generates requests for GetCommentsByActivityId
func NewGetCommentsByActivityIdRequest(server string, id int64, params *GetCommentsByActivityIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/activities/%s/comments", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AfterCursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after_cursor", runtime.ParamLocationQuery, *params.AfterCursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetKudoersByActivityIdRequest generates requests for GetKudoersByActivityId
func NewGetKudoersByActivityIdRequest(server string, id int64, params *GetKudoersByActivityIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/activities/%s/kudos", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLapsByActivityIdRequest generates requests for GetLapsByActivityId
func NewGetLapsByActivityIdRequest(server string, id int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/activities/%s/laps", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetActivityStreamsRequest generates requests for GetActivityStreams
func NewGetActivityStreamsRequest(server string, id int64, params *GetActivityStreamsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/activities/%s/streams", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "keys", runtime.ParamLocationQuery, params.Keys); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "key_by_type", runtime.ParamLocationQuery, params.KeyByType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetZonesByActivityIdRequest generates requests for GetZonesByActivityId
func NewGetZonesByActivityIdRequest(server string, id int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/activities/%s/zones", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLoggedInAthleteRequest generates requests for GetLoggedInAthlete
func NewGetLoggedInAthleteRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/athlete")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLoggedInAthleteActivitiesRequest generates requests for GetLoggedInAthleteActivities
func NewGetLoggedInAthleteActivitiesRequest(server string, params *GetLoggedInAthleteActivitiesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/athlete/activities")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Before != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, *params.Before); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLoggedInAthleteClubsRequest generates requests for GetLoggedInAthleteClubs
func NewGetLoggedInAthleteClubsRequest(server string, params *GetLoggedInAthleteClubsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/athlete/clubs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLoggedInAthleteZonesRequest generates requests for GetLoggedInAthleteZones
func NewGetLoggedInAthleteZonesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/athlete/zones")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRoutesByAthleteIdRequest generates requests for GetRoutesByAthleteId
func NewGetRoutesByAthleteIdRequest(server string, id int64, params *GetRoutesByAthleteIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/athletes/%s/routes", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStatsRequest generates requests for GetStats
func NewGetStatsRequest(server string, id int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/athletes/%s/stats", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetClubByIdRequest generates requests for GetClubById
func NewGetClubByIdRequest(server string, id int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clubs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetClubActivitiesByIdRequest generates requests for GetClubActivitiesById
func NewGetClubActivitiesByIdRequest(server string, id int64, params *GetClubActivitiesByIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clubs/%s/activities", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetClubMembersByIdRequest generates requests for GetClubMembersById
func NewGetClubMembersByIdRequest(server string, id int64, params *GetClubMembersByIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clubs/%s/members", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGearByIdRequest generates requests for GetGearById
func NewGetGearByIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/gear/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRouteByIdRequest generates requests for GetRouteById
func NewGetRouteByIdRequest(server string, id int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/routes/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEffortsBySegmentIdRequest generates requests for GetEffortsBySegmentId
func NewGetEffortsBySegmentIdRequest(server string, params *GetEffortsBySegmentIdParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/segment_efforts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "segment_id", runtime.ParamLocationQuery, params.SegmentId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.StartDateLocal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_date_local", runtime.ParamLocationQuery, *params.StartDateLocal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndDateLocal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_date_local", runtime.ParamLocationQuery, *params.EndDateLocal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSegmentEffortByIdRequest generates requests for GetSegmentEffortById
func NewGetSegmentEffortByIdRequest(server string, id int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/segment_efforts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExploreSegmentsRequest generates requests for ExploreSegments
func NewExploreSegmentsRequest(server string, params *ExploreSegmentsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/segments/explore")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", false, "bounds", runtime.ParamLocationQuery, params.Bounds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.ActivityType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "activity_type", runtime.ParamLocationQuery, *params.ActivityType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinCat != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_cat", runtime.ParamLocationQuery, *params.MinCat); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxCat != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_cat", runtime.ParamLocationQuery, *params.MaxCat); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLoggedInAthleteStarredSegmentsRequest generates requests for GetLoggedInAthleteStarredSegments
func NewGetLoggedInAthleteStarredSegmentsRequest(server string, params *GetLoggedInAthleteStarredSegmentsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/segments/starred")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "per_page", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSegmentByIdRequest generates requests for GetSegmentById
func NewGetSegmentByIdRequest(server string, id int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/segments/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetActivityByIdWithResponse request
	GetActivityByIdWithResponse(ctx context.Context, id int64, params *GetActivityByIdParams, reqEditors ...RequestEditorFn) (*GetActivityByIdResponse, error)

	// GetCommentsByActivityIdWithResponse request
	GetCommentsByActivityIdWithResponse(ctx context.Context, id int64, params *GetCommentsByActivityIdParams, reqEditors ...RequestEditorFn) (*GetCommentsByActivityIdResponse, error)

	// GetKudoersByActivityIdWithResponse request
	GetKudoersByActivityIdWithResponse(ctx context.Context, id int64, params *GetKudoersByActivityIdParams, reqEditors ...RequestEditorFn) (*GetKudoersByActivityIdResponse, error)

	// GetLapsByActivityIdWithResponse request
	GetLapsByActivityIdWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*GetLapsByActivityIdResponse, error)

	// GetActivityStreamsWithResponse request
	GetActivityStreamsWithResponse(ctx context.Context, id int64, params *GetActivityStreamsParams, reqEditors ...RequestEditorFn) (*GetActivityStreamsResponse, error)

	// GetZonesByActivityIdWithResponse request
	GetZonesByActivityIdWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*GetZonesByActivityIdResponse, error)

	// GetLoggedInAthleteWithResponse request
	GetLoggedInAthleteWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLoggedInAthleteResponse, error)

	// GetLoggedInAthleteActivitiesWithResponse request
	GetLoggedInAthleteActivitiesWithResponse(ctx context.Context, params *GetLoggedInAthleteActivitiesParams, reqEditors ...RequestEditorFn) (*GetLoggedInAthleteActivitiesResponse, error)

	// GetLoggedInAthleteClubsWithResponse request
	GetLoggedInAthleteClubsWithResponse(ctx context.Context, params *GetLoggedInAthleteClubsParams, reqEditors ...RequestEditorFn) (*GetLoggedInAthleteClubsResponse, error)

	// GetLoggedInAthleteZonesWithResponse request
	GetLoggedInAthleteZonesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLoggedInAthleteZonesResponse, error)

	// GetRoutesByAthleteIdWithResponse request
	GetRoutesByAthleteIdWithResponse(ctx context.Context, id int64, params *GetRoutesByAthleteIdParams, reqEditors ...RequestEditorFn) (*GetRoutesByAthleteIdResponse, error)

	// GetStatsWithResponse request
	GetStatsWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*GetStatsResponse, error)

	// GetClubByIdWithResponse request
	GetClubByIdWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*GetClubByIdResponse, error)

	// GetClubActivitiesByIdWithResponse request
	GetClubActivitiesByIdWithResponse(ctx context.Context, id int64, params *GetClubActivitiesByIdParams, reqEditors ...RequestEditorFn) (*GetClubActivitiesByIdResponse, error)

	// GetClubMembersByIdWithResponse request
	GetClubMembersByIdWithResponse(ctx context.Context, id int64, params *GetClubMembersByIdParams, reqEditors ...RequestEditorFn) (*GetClubMembersByIdResponse, error)

	// GetGearByIdWithResponse request
	GetGearByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetGearByIdResponse, error)

	// GetRouteByIdWithResponse request
	GetRouteByIdWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*GetRouteByIdResponse, error)

	// GetEffortsBySegmentIdWithResponse request
	GetEffortsBySegmentIdWithResponse(ctx context.Context, params *GetEffortsBySegmentIdParams, reqEditors ...RequestEditorFn) (*GetEffortsBySegmentIdResponse, error)

	// GetSegmentEffortByIdWithResponse request
	GetSegmentEffortByIdWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*GetSegmentEffortByIdResponse, error)

	// ExploreSegmentsWithResponse request
	ExploreSegmentsWithResponse(ctx context.Context, params *ExploreSegmentsParams, reqEditors ...RequestEditorFn) (*ExploreSegmentsResponse, error)

	// GetLoggedInAthleteStarredSegmentsWithResponse request
	GetLoggedInAthleteStarredSegmentsWithResponse(ctx context.Context, params *GetLoggedInAthleteStarredSegmentsParams, reqEditors ...RequestEditorFn) (*GetLoggedInAthleteStarredSegmentsResponse, error)

	// GetSegmentByIdWithResponse request
	GetSegmentByIdWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*GetSegmentByIdResponse, error)
}

type GetActivityByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AchievementCount The number of achievements gained during this activity
		AchievementCount *int `json:"achievement_count,omitempty"`
		Athlete          *struct {
			// Id The unique identifier of the athlete
			Id *int64 `json:"id,omitempty"`
		} `json:"athlete,omitempty"`

		// AthleteCount The number of athletes for taking part in a group activity
		AthleteCount *int `json:"athlete_count,omitempty"`

		// AverageSpeed The activity's average speed, in meters per second
		AverageSpeed *float32 `json:"average_speed,omitempty"`

		// AverageWatts Average power output in watts during this activity. Rides only
		AverageWatts *float32 `json:"average_watts,omitempty"`
		BestEfforts  *[]struct {
			Activity *struct {
				// Id The unique identifier of the activity
				Id *int64 `json:"id,omitempty"`
			} `json:"activity,omitempty"`

			// ActivityId The unique identifier of the activity related to this effort
			ActivityId *int64 `json:"activity_id,omitempty"`
			Athlete    *struct {
				// Id The unique identifier of the athlete
				Id *int64 `json:"id,omitempty"`
			} `json:"athlete,omitempty"`

			// AverageCadence The effort's average cadence
			AverageCadence *float32 `json:"average_cadence,omitempty"`

			// AverageHeartrate The heart heart rate of the athlete during this effort
			AverageHeartrate *float32 `json:"average_heartrate,omitempty"`

			// AverageWatts The average wattage of this effort
			AverageWatts *float32 `json:"average_watts,omitempty"`

			// DeviceWatts For riding efforts, whether the wattage was reported by a dedicated recording device
			DeviceWatts *bool `json:"device_watts,omitempty"`

			// Distance The effort's distance in meters
			Distance *float32 `json:"distance,omitempty"`

			// ElapsedTime The effort's elapsed time
			ElapsedTime *int `json:"elapsed_time,omitempty"`

			// EndIndex The end index of this effort in its activity's stream
			EndIndex *int `json:"end_index,omitempty"`

			// Hidden Whether this effort should be hidden when viewed within an activity
			Hidden *bool `json:"hidden,omitempty"`

			// Id The unique identifier of this effort
			Id *int64 `json:"id,omitempty"`

			// IsKom Whether this effort is the current best on the leaderboard
			IsKom *bool `json:"is_kom,omitempty"`

			// KomRank The rank of the effort on the global leaderboard if it belongs in the top 10 at the time of upload
			KomRank *int `json:"kom_rank,omitempty"`

			// MaxHeartrate The maximum heart rate of the athlete during this effort
			MaxHeartrate *float32 `json:"max_heartrate,omitempty"`

			// MovingTime The effort's moving time
			MovingTime *int `json:"moving_time,omitempty"`

			// Name The name of the segment on which this effort was performed
			Name *string `json:"name,omitempty"`

			// PrRank The rank of the effort on the athlete's leaderboard if it belongs in the top 3 at the time of upload
			PrRank  *int `json:"pr_rank,omitempty"`
			Segment *struct {
				ActivityType    *GetActivityById200BestEffortsSegmentActivityType `json:"activity_type,omitempty"`
				AthletePrEffort *struct {
					// EffortCount Number of efforts by the authenticated athlete on this segment.
					EffortCount *int `json:"effort_count,omitempty"`

					// PrActivityId The unique identifier of the activity related to the PR effort.
					PrActivityId *int64 `json:"pr_activity_id,omitempty"`

					// PrDate The time at which the PR effort was started.
					PrDate *time.Time `json:"pr_date,omitempty"`

					// PrElapsedTime The elapsed time ot the PR effort.
					PrElapsedTime *int `json:"pr_elapsed_time,omitempty"`
				} `json:"athlete_pr_effort,omitempty"`
				AthleteSegmentStats *struct {
					// ActivityId The unique identifier of the activity related to this effort
					ActivityId *int64 `json:"activity_id,omitempty"`

					// Distance The effort's distance in meters
					Distance *float32 `json:"distance,omitempty"`

					// ElapsedTime The effort's elapsed time
					ElapsedTime *int `json:"elapsed_time,omitempty"`

					// Id The unique identifier of this effort
					Id *int64 `json:"id,omitempty"`

					// IsKom Whether this effort is the current best on the leaderboard
					IsKom *bool `json:"is_kom,omitempty"`

					// StartDate The time at which the effort was started.
					StartDate *time.Time `json:"start_date,omitempty"`

					// StartDateLocal The time at which the effort was started in the local timezone.
					StartDateLocal *time.Time `json:"start_date_local,omitempty"`
				} `json:"athlete_segment_stats,omitempty"`

				// AverageGrade The segment's average grade, in percents
				AverageGrade *float32 `json:"average_grade,omitempty"`

				// City The segments's city.
				City *string `json:"city,omitempty"`

				// ClimbCategory The category of the climb [0, 5]. Higher is harder ie. 5 is Hors catgorie, 0 is uncategorized in climb_category.
				ClimbCategory *int `json:"climb_category,omitempty"`

				// Country The segment's country.
				Country *string `json:"country,omitempty"`

				// Distance The segment's distance, in meters
				Distance *float32 `json:"distance,omitempty"`

				// ElevationHigh The segments's highest elevation, in meters
				ElevationHigh *float32 `json:"elevation_high,omitempty"`

				// ElevationLow The segments's lowest elevation, in meters
				ElevationLow *float32 `json:"elevation_low,omitempty"`

				// EndLatlng A pair of latitude/longitude coordinates, represented as an array of 2 floating point numbers.
				EndLatlng *[]float32 `json:"end_latlng,omitempty"`

				// Id The unique identifier of this segment
				Id *int64 `json:"id,omitempty"`

				// MaximumGrade The segments's maximum grade, in percents
				MaximumGrade *float32 `json:"maximum_grade,omitempty"`

				// Name The name of this segment
				Name *string `json:"name,omitempty"`

				// Private Whether this segment is private.
				Private *bool `json:"private,omitempty"`

				// StartLatlng A pair of latitude/longitude coordinates, represented as an array of 2 floating point numbers.
				StartLatlng *[]float32 `json:"start_latlng,omitempty"`

				// State The segments's state or geographical region.
				State *string `json:"state,omitempty"`
			} `json:"segment,omitempty"`

			// StartDate The time at which the effort was started.
			StartDate *time.Time `json:"start_date,omitempty"`

			// StartDateLocal The time at which the effort was started in the local timezone.
			StartDateLocal *time.Time `json:"start_date_local,omitempty"`

			// StartIndex The start index of this effort in its activity's stream
			StartIndex *int `json:"start_index,omitempty"`
		} `json:"best_efforts,omitempty"`

		// Calories The number of kilocalories consumed during this activity
		Calories *float32 `json:"calories,omitempty"`

		// CommentCount The number of comments for this activity
		CommentCount *int `json:"comment_count,omitempty"`

		// Commute Whether this activity is a commute
		Commute *bool `json:"commute,omitempty"`

		// Description The description of the activity
		Description *string `json:"description,omitempty"`

		// DeviceName The name of the device used to record the activity
		DeviceName *string `json:"device_name,omitempty"`

		// DeviceWatts Whether the watts are from a power meter, false if estimated
		DeviceWatts *bool `json:"device_watts,omitempty"`

		// Distance The activity's distance, in meters
		Distance *float32 `json:"distance,omitempty"`

		// ElapsedTime The activity's elapsed time, in seconds
		ElapsedTime *int `json:"elapsed_time,omitempty"`

		// ElevHigh The activity's highest elevation, in meters
		ElevHigh *float32 `json:"elev_high,omitempty"`

		// ElevLow The activity's lowest elevation, in meters
		ElevLow *float32 `json:"elev_low,omitempty"`

		// EmbedToken The token used to embed a Strava activity
		EmbedToken *string `json:"embed_token,omitempty"`

		// EndLatlng A pair of latitude/longitude coordinates, represented as an array of 2 floating point numbers.
		EndLatlng *[]float32 `json:"end_latlng,omitempty"`

		// ExternalId The identifier provided at upload time
		ExternalId *string `json:"external_id,omitempty"`

		// Flagged Whether this activity is flagged
		Flagged *bool `json:"flagged,omitempty"`
		Gear    *struct {
			// Distance The distance logged with this gear.
			Distance *float32 `json:"distance,omitempty"`

			// Id The gear's unique identifier.
			Id *string `json:"id,omitempty"`

			// Name The gear's name.
			Name *string `json:"name,omitempty"`

			// Primary Whether this gear's is the owner's default one.
			Primary *bool `json:"primary,omitempty"`

			// ResourceState Resource state, indicates level of detail. Possible values: 2 -> "summary", 3 -> "detail"
			ResourceState *int `json:"resource_state,omitempty"`
		} `json:"gear,omitempty"`

		// GearId The id of the gear for the activity
		GearId *string `json:"gear_id,omitempty"`

		// HasKudoed Whether the logged-in athlete has kudoed this activity
		HasKudoed *bool `json:"has_kudoed,omitempty"`

		// HideFromHome Whether the activity is muted
		HideFromHome *bool `json:"hide_from_home,omitempty"`

		// Id The unique identifier of the activity
		Id *int64 `json:"id,omitempty"`

		// Kilojoules The total work done in kilojoules during this activity. Rides only
		Kilojoules *float32 `json:"kilojoules,omitempty"`

		// KudosCount The number of kudos given for this activity
		KudosCount *int `json:"kudos_count,omitempty"`
		Laps       *[]struct {
			Activity *struct {
				// Id The unique identifier of the activity
				Id *int64 `json:"id,omitempty"`
			} `json:"activity,omitempty"`
			Athlete *struct {
				// Id The unique identifier of the athlete
				Id *int64 `json:"id,omitempty"`
			} `json:"athlete,omitempty"`

			// AverageCadence The lap's average cadence
			AverageCadence *float32 `json:"average_cadence,omitempty"`

			// AverageSpeed The lap's average speed
			AverageSpeed *float32 `json:"average_speed,omitempty"`

			// Distance The lap's distance, in meters
			Distance *float32 `json:"distance,omitempty"`

			// ElapsedTime The lap's elapsed time, in seconds
			ElapsedTime *int `json:"elapsed_time,omitempty"`

			// EndIndex The end index of this effort in its activity's stream
			EndIndex *int `json:"end_index,omitempty"`

			// Id The unique identifier of this lap
			Id *int64 `json:"id,omitempty"`

			// LapIndex The index of this lap in the activity it belongs to
			LapIndex *int `json:"lap_index,omitempty"`

			// MaxSpeed The maximum speed of this lat, in meters per second
			MaxSpeed *float32 `json:"max_speed,omitempty"`

			// MovingTime The lap's moving time, in seconds
			MovingTime *int `json:"moving_time,omitempty"`

			// Name The name of the lap
			Name *string `json:"name,omitempty"`

			// PaceZone The athlete's pace zone during this lap
			PaceZone *int `json:"pace_zone,omitempty"`
			Split    *int `json:"split,omitempty"`

			// StartDate The time at which the lap was started.
			StartDate *time.Time `json:"start_date,omitempty"`

			// StartDateLocal The time at which the lap was started in the local timezone.
			StartDateLocal *time.Time `json:"start_date_local,omitempty"`

			// StartIndex The start index of this effort in its activity's stream
			StartIndex *int `json:"start_index,omitempty"`

			// TotalElevationGain The elevation gain of this lap, in meters
			TotalElevationGain *float32 `json:"total_elevation_gain,omitempty"`
		} `json:"laps,omitempty"`

		// Manual Whether this activity was created manually
		Manual *bool `json:"manual,omitempty"`
		Map    *struct {
			// Id The identifier of the map
			Id *string `json:"id,omitempty"`

			// Polyline The polyline of the map, only returned on detailed representation of an object
			Polyline *string `json:"polyline,omitempty"`

			// SummaryPolyline The summary polyline of the map
			SummaryPolyline *string `json:"summary_polyline,omitempty"`
		} `json:"map,omitempty"`

		// MaxSpeed The activity's max speed, in meters per second
		MaxSpeed *float32 `json:"max_speed,omitempty"`

		// MaxWatts Rides with power meter data only
		MaxWatts *int `json:"max_watts,omitempty"`

		// MovingTime The activity's moving time, in seconds
		MovingTime *int `json:"moving_time,omitempty"`

		// Name The name of the activity
		Name *string `json:"name,omitempty"`

		// PhotoCount The number of Instagram photos for this activity
		PhotoCount *int `json:"photo_count,omitempty"`
		Photos     *struct {
			// Count The number of photos
			Count   *int `json:"count,omitempty"`
			Primary *struct {
				Id       *int64             `json:"id,omitempty"`
				Source   *int               `json:"source,omitempty"`
				UniqueId *string            `json:"unique_id,omitempty"`
				Urls     *map[string]string `json:"urls,omitempty"`
			} `json:"primary,omitempty"`
		} `json:"photos,omitempty"`

		// Private Whether this activity is private
		Private        *bool `json:"private,omitempty"`
		SegmentEfforts *[]struct {
			Activity *struct {
				// Id The unique identifier of the activity
				Id *int64 `json:"id,omitempty"`
			} `json:"activity,omitempty"`

			// ActivityId The unique identifier of the activity related to this effort
			ActivityId *int64 `json:"activity_id,omitempty"`
			Athlete    *struct {
				// Id The unique identifier of the athlete
				Id *int64 `json:"id,omitempty"`
			} `json:"athlete,omitempty"`

			// AverageCadence The effort's average cadence
			AverageCadence *float32 `json:"average_cadence,omitempty"`

			// AverageHeartrate The heart heart rate of the athlete during this effort
			AverageHeartrate *float32 `json:"average_heartrate,omitempty"`

			// AverageWatts The average wattage of this effort
			AverageWatts *float32 `json:"average_watts,omitempty"`

			// DeviceWatts For riding efforts, whether the wattage was reported by a dedicated recording device
			DeviceWatts *bool `json:"device_watts,omitempty"`

			// Distance The effort's distance in meters
			Distance *float32 `json:"distance,omitempty"`

			// ElapsedTime The effort's elapsed time
			ElapsedTime *int `json:"elapsed_time,omitempty"`

			// EndIndex The end index of this effort in its activity's stream
			EndIndex *int `json:"end_index,omitempty"`

			// Hidden Whether this effort should be hidden when viewed within an activity
			Hidden *bool `json:"hidden,omitempty"`

			// Id The unique identifier of this effort
			Id *int64 `json:"id,omitempty"`

			// IsKom Whether this effort is the current best on the leaderboard
			IsKom *bool `json:"is_kom,omitempty"`

			// KomRank The rank of the effort on the global leaderboard if it belongs in the top 10 at the time of upload
			KomRank *int `json:"kom_rank,omitempty"`

			// MaxHeartrate The maximum heart rate of the athlete during this effort
			MaxHeartrate *float32 `json:"max_heartrate,omitempty"`

			// MovingTime The effort's moving time
			MovingTime *int `json:"moving_time,omitempty"`

			// Name The name of the segment on which this effort was performed
			Name *string `json:"name,omitempty"`

			// PrRank The rank of the effort on the athlete's leaderboard if it belongs in the top 3 at the time of upload
			PrRank  *int `json:"pr_rank,omitempty"`
			Segment *struct {
				ActivityType    *GetActivityById200SegmentEffortsSegmentActivityType `json:"activity_type,omitempty"`
				AthletePrEffort *struct {
					// EffortCount Number of efforts by the authenticated athlete on this segment.
					EffortCount *int `json:"effort_count,omitempty"`

					// PrActivityId The unique identifier of the activity related to the PR effort.
					PrActivityId *int64 `json:"pr_activity_id,omitempty"`

					// PrDate The time at which the PR effort was started.
					PrDate *time.Time `json:"pr_date,omitempty"`

					// PrElapsedTime The elapsed time ot the PR effort.
					PrElapsedTime *int `json:"pr_elapsed_time,omitempty"`
				} `json:"athlete_pr_effort,omitempty"`
				AthleteSegmentStats *struct {
					// ActivityId The unique identifier of the activity related to this effort
					ActivityId *int64 `json:"activity_id,omitempty"`

					// Distance The effort's distance in meters
					Distance *float32 `json:"distance,omitempty"`

					// ElapsedTime The effort's elapsed time
					ElapsedTime *int `json:"elapsed_time,omitempty"`

					// Id The unique identifier of this effort
					Id *int64 `json:"id,omitempty"`

					// IsKom Whether this effort is the current best on the leaderboard
					IsKom *bool `json:"is_kom,omitempty"`

					// StartDate The time at which the effort was started.
					StartDate *time.Time `json:"start_date,omitempty"`

					// StartDateLocal The time at which the effort was started in the local timezone.
					StartDateLocal *time.Time `json:"start_date_local,omitempty"`
				} `json:"athlete_segment_stats,omitempty"`

				// AverageGrade The segment's average grade, in percents
				AverageGrade *float32 `json:"average_grade,omitempty"`

				// City The segments's city.
				City *string `json:"city,omitempty"`

				// ClimbCategory The category of the climb [0, 5]. Higher is harder ie. 5 is Hors catgorie, 0 is uncategorized in climb_category.
				ClimbCategory *int `json:"climb_category,omitempty"`

				// Country The segment's country.
				Country *string `json:"country,omitempty"`

				// Distance The segment's distance, in meters
				Distance *float32 `json:"distance,omitempty"`

				// ElevationHigh The segments's highest elevation, in meters
				ElevationHigh *float32 `json:"elevation_high,omitempty"`

				// ElevationLow The segments's lowest elevation, in meters
				ElevationLow *float32 `json:"elevation_low,omitempty"`

				// EndLatlng A pair of latitude/longitude coordinates, represented as an array of 2 floating point numbers.
				EndLatlng *[]float32 `json:"end_latlng,omitempty"`

				// Id The unique identifier of this segment
				Id *int64 `json:"id,omitempty"`

				// MaximumGrade The segments's maximum grade, in percents
				MaximumGrade *float32 `json:"maximum_grade,omitempty"`

				// Name The name of this segment
				Name *string `json:"name,omitempty"`

				// Private Whether this segment is private.
				Private *bool `json:"private,omitempty"`

				// StartLatlng A pair of latitude/longitude coordinates, represented as an array of 2 floating point numbers.
				StartLatlng *[]float32 `json:"start_latlng,omitempty"`

				// State The segments's state or geographical region.
				State *string `json:"state,omitempty"`
			} `json:"segment,omitempty"`

			// StartDate The time at which the effort was started.
			StartDate *time.Time `json:"start_date,omitempty"`

			// StartDateLocal The time at which the effort was started in the local timezone.
			StartDateLocal *time.Time `json:"start_date_local,omitempty"`

			// StartIndex The start index of this effort in its activity's stream
			StartIndex *int `json:"start_index,omitempty"`
		} `json:"segment_efforts,omitempty"`

		// SplitsMetric The splits of this activity in metric units (for runs)
		SplitsMetric *[]struct {
			// AverageSpeed The average speed of this split, in meters per second
			AverageSpeed *float32 `json:"average_speed,omitempty"`

			// Distance The distance of this split, in meters
			Distance *float32 `json:"distance,omitempty"`

			// ElapsedTime The elapsed time of this split, in seconds
			ElapsedTime *int `json:"elapsed_time,omitempty"`

			// ElevationDifference The elevation difference of this split, in meters
			ElevationDifference *float32 `json:"elevation_difference,omitempty"`

			// MovingTime The moving time of this split, in seconds
			MovingTime *int `json:"moving_time,omitempty"`

			// PaceZone The pacing zone of this split
			PaceZone *int `json:"pace_zone,omitempty"`

			// Split N/A
			Split *int `json:"split,omitempty"`
		} `json:"splits_metric,omitempty"`

		// SplitsStandard The splits of this activity in imperial units (for runs)
		SplitsStandard *[]struct {
			// AverageSpeed The average speed of this split, in meters per second
			AverageSpeed *float32 `json:"average_speed,omitempty"`

			// Distance The distance of this split, in meters
			Distance *float32 `json:"distance,omitempty"`

			// ElapsedTime The elapsed time of this split, in seconds
			ElapsedTime *int `json:"elapsed_time,omitempty"`

			// ElevationDifference The elevation difference of this split, in meters
			ElevationDifference *float32 `json:"elevation_difference,omitempty"`

			// MovingTime The moving time of this split, in seconds
			MovingTime *int `json:"moving_time,omitempty"`

			// PaceZone The pacing zone of this split
			PaceZone *int `json:"pace_zone,omitempty"`

			// Split N/A
			Split *int `json:"split,omitempty"`
		} `json:"splits_standard,omitempty"`

		// SportType An enumeration of the sport types an activity may have. Distinct from ActivityType in that it has new types (e.g. MountainBikeRide)
		SportType *GetActivityById200SportType `json:"sport_type,omitempty"`

		// StartDate The time at which the activity was started.
		StartDate *time.Time `json:"start_date,omitempty"`

		// StartDateLocal The time at which the activity was started in the local timezone.
		StartDateLocal *time.Time `json:"start_date_local,omitempty"`

		// StartLatlng A pair of latitude/longitude coordinates, represented as an array of 2 floating point numbers.
		StartLatlng *[]float32 `json:"start_latlng,omitempty"`

		// Timezone The timezone of the activity
		Timezone *string `json:"timezone,omitempty"`

		// TotalElevationGain The activity's total elevation gain.
		TotalElevationGain *float32 `json:"total_elevation_gain,omitempty"`

		// TotalPhotoCount The number of Instagram and Strava photos for this activity
		TotalPhotoCount *int `json:"total_photo_count,omitempty"`

		// Trainer Whether this activity was recorded on a training machine
		Trainer *bool `json:"trainer,omitempty"`

		// Type Deprecated. Prefer to use sport_type
		Type *GetActivityById200Type `json:"type,omitempty"`

		// UploadId The identifier of the upload that resulted in this activity
		UploadId *int64 `json:"upload_id,omitempty"`

		// UploadIdStr The unique identifier of the upload in string format
		UploadIdStr *string `json:"upload_id_str,omitempty"`

		// WeightedAverageWatts Similar to Normalized Power. Rides with power meter data only
		WeightedAverageWatts *int `json:"weighted_average_watts,omitempty"`

		// WorkoutType The activity's workout type
		WorkoutType *int `json:"workout_type,omitempty"`
	}
	JSONDefault *struct {
		// Errors The set of specific errors associated with this fault, if any.
		Errors *[]struct {
			// Code The code associated with this error.
			Code *string `json:"code,omitempty"`

			// Field The specific field or aspect of the resource associated with this error.
			Field *string `json:"field,omitempty"`

			// Resource The type of resource associated with this error.
			Resource *string `json:"resource,omitempty"`
		} `json:"errors,omitempty"`

		// Message The message of the fault.
		Message *string `json:"message,omitempty"`
	}
}
type GetActivityById200BestEffortsSegmentActivityType string
type GetActivityById200SegmentEffortsSegmentActivityType string
type GetActivityById200SportType string
type GetActivityById200Type string

// Status returns HTTPResponse.Status
func (r GetActivityByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetActivityByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCommentsByActivityIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		// ActivityId The identifier of the activity this comment is related to
		ActivityId *int64 `json:"activity_id,omitempty"`
		Athlete    *struct {
			// City The athlete's city.
			City *string `json:"city,omitempty"`

			// Country The athlete's country.
			Country *string `json:"country,omitempty"`

			// CreatedAt The time at which the athlete was created.
			CreatedAt *time.Time `json:"created_at,omitempty"`

			// Firstname The athlete's first name.
			Firstname *string `json:"firstname,omitempty"`

			// Id The unique identifier of the athlete
			Id *int64 `json:"id,omitempty"`

			// Lastname The athlete's last name.
			Lastname *string `json:"lastname,omitempty"`

			// Premium Deprecated.  Use summit field instead. Whether the athlete has any Summit subscription.
			Premium *bool `json:"premium,omitempty"`

			// Profile URL to a 124x124 pixel profile picture.
			Profile *string `json:"profile,omitempty"`

			// ProfileMedium URL to a 62x62 pixel profile picture.
			ProfileMedium *string `json:"profile_medium,omitempty"`

			// ResourceState Resource state, indicates level of detail. Possible values: 1 -> "meta", 2 -> "summary", 3 -> "detail"
			ResourceState *int `json:"resource_state,omitempty"`

			// Sex The athlete's sex.
			Sex *GetCommentsByActivityId200AthleteSex `json:"sex,omitempty"`

			// State The athlete's state or geographical region.
			State *string `json:"state,omitempty"`

			// Summit Whether the athlete has any Summit subscription.
			Summit *bool `json:"summit,omitempty"`

			// UpdatedAt The time at which the athlete was last updated.
			UpdatedAt *time.Time `json:"updated_at,omitempty"`
		} `json:"athlete,omitempty"`

		// CreatedAt The time at which this comment was created.
		CreatedAt *time.Time `json:"created_at,omitempty"`

		// Id The unique identifier of this comment
		Id *int64 `json:"id,omitempty"`

		// Text The content of the comment
		Text *string `json:"text,omitempty"`
	}
	JSONDefault *struct {
		// Errors The set of specific errors associated with this fault, if any.
		Errors *[]struct {
			// Code The code associated with this error.
			Code *string `json:"code,omitempty"`

			// Field The specific field or aspect of the resource associated with this error.
			Field *string `json:"field,omitempty"`

			// Resource The type of resource associated with this error.
			Resource *string `json:"resource,omitempty"`
		} `json:"errors,omitempty"`

		// Message The message of the fault.
		Message *string `json:"message,omitempty"`
	}
}
type GetCommentsByActivityId200AthleteSex string

// Status returns HTTPResponse.Status
func (r GetCommentsByActivityIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCommentsByActivityIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetKudoersByActivityIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		// City The athlete's city.
		City *string `json:"city,omitempty"`

		// Country The athlete's country.
		Country *string `json:"country,omitempty"`

		// CreatedAt The time at which the athlete was created.
		CreatedAt *time.Time `json:"created_at,omitempty"`

		// Firstname The athlete's first name.
		Firstname *string `json:"firstname,omitempty"`

		// Id The unique identifier of the athlete
		Id *int64 `json:"id,omitempty"`

		// Lastname The athlete's last name.
		Lastname *string `json:"lastname,omitempty"`

		// Premium Deprecated.  Use summit field instead. Whether the athlete has any Summit subscription.
		Premium *bool `json:"premium,omitempty"`

		// Profile URL to a 124x124 pixel profile picture.
		Profile *string `json:"profile,omitempty"`

		// ProfileMedium URL to a 62x62 pixel profile picture.
		ProfileMedium *string `json:"profile_medium,omitempty"`

		// ResourceState Resource state, indicates level of detail. Possible values: 1 -> "meta", 2 -> "summary", 3 -> "detail"
		ResourceState *int `json:"resource_state,omitempty"`

		// Sex The athlete's sex.
		Sex *GetKudoersByActivityId200Sex `json:"sex,omitempty"`

		// State The athlete's state or geographical region.
		State *string `json:"state,omitempty"`

		// Summit Whether the athlete has any Summit subscription.
		Summit *bool `json:"summit,omitempty"`

		// UpdatedAt The time at which the athlete was last updated.
		UpdatedAt *time.Time `json:"updated_at,omitempty"`
	}
	JSONDefault *struct {
		// Errors The set of specific errors associated with this fault, if any.
		Errors *[]struct {
			// Code The code associated with this error.
			Code *string `json:"code,omitempty"`

			// Field The specific field or aspect of the resource associated with this error.
			Field *string `json:"field,omitempty"`

			// Resource The type of resource associated with this error.
			Resource *string `json:"resource,omitempty"`
		} `json:"errors,omitempty"`

		// Message The message of the fault.
		Message *string `json:"message,omitempty"`
	}
}
type GetKudoersByActivityId200Sex string

// Status returns HTTPResponse.Status
func (r GetKudoersByActivityIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetKudoersByActivityIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLapsByActivityIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		Activity *struct {
			// Id The unique identifier of the activity
			Id *int64 `json:"id,omitempty"`
		} `json:"activity,omitempty"`
		Athlete *struct {
			// Id The unique identifier of the athlete
			Id *int64 `json:"id,omitempty"`
		} `json:"athlete,omitempty"`

		// AverageCadence The lap's average cadence
		AverageCadence *float32 `json:"average_cadence,omitempty"`

		// AverageSpeed The lap's average speed
		AverageSpeed *float32 `json:"average_speed,omitempty"`

		// Distance The lap's distance, in meters
		Distance *float32 `json:"distance,omitempty"`

		// ElapsedTime The lap's elapsed time, in seconds
		ElapsedTime *int `json:"elapsed_time,omitempty"`

		// EndIndex The end index of this effort in its activity's stream
		EndIndex *int `json:"end_index,omitempty"`

		// Id The unique identifier of this lap
		Id *int64 `json:"id,omitempty"`

		// LapIndex The index of this lap in the activity it belongs to
		LapIndex *int `json:"lap_index,omitempty"`

		// MaxSpeed The maximum speed of this lat, in meters per second
		MaxSpeed *float32 `json:"max_speed,omitempty"`

		// MovingTime The lap's moving time, in seconds
		MovingTime *int `json:"moving_time,omitempty"`

		// Name The name of the lap
		Name *string `json:"name,omitempty"`

		// PaceZone The athlete's pace zone during this lap
		PaceZone *int `json:"pace_zone,omitempty"`
		Split    *int `json:"split,omitempty"`

		// StartDate The time at which the lap was started.
		StartDate *time.Time `json:"start_date,omitempty"`

		// StartDateLocal The time at which the lap was started in the local timezone.
		StartDateLocal *time.Time `json:"start_date_local,omitempty"`

		// StartIndex The start index of this effort in its activity's stream
		StartIndex *int `json:"start_index,omitempty"`

		// TotalElevationGain The elevation gain of this lap, in meters
		TotalElevationGain *float32 `json:"total_elevation_gain,omitempty"`
	}
	JSONDefault *struct {
		// Errors The set of specific errors associated with this fault, if any.
		Errors *[]struct {
			// Code The code associated with this error.
			Code *string `json:"code,omitempty"`

			// Field The specific field or aspect of the resource associated with this error.
			Field *string `json:"field,omitempty"`

			// Resource The type of resource associated with this error.
			Resource *string `json:"resource,omitempty"`
		} `json:"errors,omitempty"`

		// Message The message of the fault.
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetLapsByActivityIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLapsByActivityIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetActivityStreamsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Altitude *struct {
			// Data The sequence of altitude values for this stream, in meters
			Data *[]float32 `json:"data,omitempty"`

			// OriginalSize The number of data points in this stream
			OriginalSize *int `json:"original_size,omitempty"`

			// Resolution The level of detail (sampling) in which this stream was returned
			Resolution *GetActivityStreams200AltitudeResolution `json:"resolution,omitempty"`

			// SeriesType The base series used in the case the stream was downsampled
			SeriesType *GetActivityStreams200AltitudeSeriesType `json:"series_type,omitempty"`
		} `json:"altitude,omitempty"`
		Cadence *struct {
			// Data The sequence of cadence values for this stream, in rotations per minute
			Data *[]int `json:"data,omitempty"`

			// OriginalSize The number of data points in this stream
			OriginalSize *int `json:"original_size,omitempty"`

			// Resolution The level of detail (sampling) in which this stream was returned
			Resolution *GetActivityStreams200CadenceResolution `json:"resolution,omitempty"`

			// SeriesType The base series used in the case the stream was downsampled
			SeriesType *GetActivityStreams200CadenceSeriesType `json:"series_type,omitempty"`
		} `json:"cadence,omitempty"`
		Distance *struct {
			// Data The sequence of distance values for this stream, in meters
			Data *[]float32 `json:"data,omitempty"`

			// OriginalSize The number of data points in this stream
			OriginalSize *int `json:"original_size,omitempty"`

			// Resolution The level of detail (sampling) in which this stream was returned
			Resolution *GetActivityStreams200DistanceResolution `json:"resolution,omitempty"`

			// SeriesType The base series used in the case the stream was downsampled
			SeriesType *GetActivityStreams200DistanceSeriesType `json:"series_type,omitempty"`
		} `json:"distance,omitempty"`
		GradeSmooth *struct {
			// Data The sequence of grade values for this stream, as percents of a grade
			Data *[]float32 `json:"data,omitempty"`

			// OriginalSize The number of data points in this stream
			OriginalSize *int `json:"original_size,omitempty"`

			// Resolution The level of detail (sampling) in which this stream was returned
			Resolution *GetActivityStreams200GradeSmoothResolution `json:"resolution,omitempty"`

			// SeriesType The base series used in the case the stream was downsampled
			SeriesType *GetActivityStreams200GradeSmoothSeriesType `json:"series_type,omitempty"`
		} `json:"grade_smooth,omitempty"`
		Heartrate *struct {
			// Data The sequence of heart rate values for this stream, in beats per minute
			Data *[]int `json:"data,omitempty"`

			// OriginalSize The number of data points in this stream
			OriginalSize *int `json:"original_size,omitempty"`

			// Resolution The level of detail (sampling) in which this stream was returned
			Resolution *GetActivityStreams200HeartrateResolution `json:"resolution,omitempty"`

			// SeriesType The base series used in the case the stream was downsampled
			SeriesType *GetActivityStreams200HeartrateSeriesType `json:"series_type,omitempty"`
		} `json:"heartrate,omitempty"`
		Latlng *struct {
			// Data The sequence of lat/long values for this stream
			Data *[][]float32 `json:"data,omitempty"`

			// OriginalSize The number of data points in this stream
			OriginalSize *int `json:"original_size,omitempty"`

			// Resolution The level of detail (sampling) in which this stream was returned
			Resolution *GetActivityStreams200LatlngResolution `json:"resolution,omitempty"`

			// SeriesType The base series used in the case the stream was downsampled
			SeriesType *GetActivityStreams200LatlngSeriesType `json:"series_type,omitempty"`
		} `json:"latlng,omitempty"`
		Moving *struct {
			// Data The sequence of moving values for this stream, as boolean values
			Data *[]bool `json:"data,omitempty"`

			// OriginalSize The number of data points in this stream
			OriginalSize *int `json:"original_size,omitempty"`

			// Resolution The level of detail (sampling) in which this stream was returned
			Resolution *GetActivityStreams200MovingResolution `json:"resolution,omitempty"`

			// SeriesType The base series used in the case the stream was downsampled
			SeriesType *GetActivityStreams200MovingSeriesType `json:"series_type,omitempty"`
		} `json:"moving,omitempty"`
		Temp *struct {
			// Data The sequence of temperature values for this stream, in celsius degrees
			Data *[]int `json:"data,omitempty"`

			// OriginalSize The number of data points in this stream
			OriginalSize *int `json:"original_size,omitempty"`

			// Resolution The level of detail (sampling) in which this stream was returned
			Resolution *GetActivityStreams200TempResolution `json:"resolution,omitempty"`

			// SeriesType The base series used in the case the stream was downsampled
			SeriesType *GetActivityStreams200TempSeriesType `json:"series_type,omitempty"`
		} `json:"temp,omitempty"`
		Time *struct {
			// Data The sequence of time values for this stream, in seconds
			Data *[]int `json:"data,omitempty"`

			// OriginalSize The number of data points in this stream
			OriginalSize *int `json:"original_size,omitempty"`

			// Resolution The level of detail (sampling) in which this stream was returned
			Resolution *GetActivityStreams200TimeResolution `json:"resolution,omitempty"`

			// SeriesType The base series used in the case the stream was downsampled
			SeriesType *GetActivityStreams200TimeSeriesType `json:"series_type,omitempty"`
		} `json:"time,omitempty"`
		VelocitySmooth *struct {
			// Data The sequence of velocity values for this stream, in meters per second
			Data *[]float32 `json:"data,omitempty"`

			// OriginalSize The number of data points in this stream
			OriginalSize *int `json:"original_size,omitempty"`

			// Resolution The level of detail (sampling) in which this stream was returned
			Resolution *GetActivityStreams200VelocitySmoothResolution `json:"resolution,omitempty"`

			// SeriesType The base series used in the case the stream was downsampled
			SeriesType *GetActivityStreams200VelocitySmoothSeriesType `json:"series_type,omitempty"`
		} `json:"velocity_smooth,omitempty"`
		Watts *struct {
			// Data The sequence of power values for this stream, in watts
			Data *[]int `json:"data,omitempty"`

			// OriginalSize The number of data points in this stream
			OriginalSize *int `json:"original_size,omitempty"`

			// Resolution The level of detail (sampling) in which this stream was returned
			Resolution *GetActivityStreams200WattsResolution `json:"resolution,omitempty"`

			// SeriesType The base series used in the case the stream was downsampled
			SeriesType *GetActivityStreams200WattsSeriesType `json:"series_type,omitempty"`
		} `json:"watts,omitempty"`
	}
	JSONDefault *struct {
		// Errors The set of specific errors associated with this fault, if any.
		Errors *[]struct {
			// Code The code associated with this error.
			Code *string `json:"code,omitempty"`

			// Field The specific field or aspect of the resource associated with this error.
			Field *string `json:"field,omitempty"`

			// Resource The type of resource associated with this error.
			Resource *string `json:"resource,omitempty"`
		} `json:"errors,omitempty"`

		// Message The message of the fault.
		Message *string `json:"message,omitempty"`
	}
}
type GetActivityStreams200AltitudeResolution string
type GetActivityStreams200AltitudeSeriesType string
type GetActivityStreams200CadenceResolution string
type GetActivityStreams200CadenceSeriesType string
type GetActivityStreams200DistanceResolution string
type GetActivityStreams200DistanceSeriesType string
type GetActivityStreams200GradeSmoothResolution string
type GetActivityStreams200GradeSmoothSeriesType string
type GetActivityStreams200HeartrateResolution string
type GetActivityStreams200HeartrateSeriesType string
type GetActivityStreams200LatlngResolution string
type GetActivityStreams200LatlngSeriesType string
type GetActivityStreams200MovingResolution string
type GetActivityStreams200MovingSeriesType string
type GetActivityStreams200TempResolution string
type GetActivityStreams200TempSeriesType string
type GetActivityStreams200TimeResolution string
type GetActivityStreams200TimeSeriesType string
type GetActivityStreams200VelocitySmoothResolution string
type GetActivityStreams200VelocitySmoothSeriesType string
type GetActivityStreams200WattsResolution string
type GetActivityStreams200WattsSeriesType string

// Status returns HTTPResponse.Status
func (r GetActivityStreamsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetActivityStreamsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetZonesByActivityIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		CustomZones *bool `json:"custom_zones,omitempty"`

		// DistributionBuckets Stores the exclusive ranges representing zones and the time spent in each.
		DistributionBuckets *[]struct {
			// Max The maximum value in the range.
			Max *int `json:"max,omitempty"`

			// Min The minimum value in the range.
			Min *int `json:"min,omitempty"`

			// Time The number of seconds spent in this zone
			Time *int `json:"time,omitempty"`
		} `json:"distribution_buckets,omitempty"`
		Max         *int                         `json:"max,omitempty"`
		Points      *int                         `json:"points,omitempty"`
		Score       *int                         `json:"score,omitempty"`
		SensorBased *bool                        `json:"sensor_based,omitempty"`
		Type        *GetZonesByActivityId200Type `json:"type,omitempty"`
	}
	JSONDefault *struct {
		// Errors The set of specific errors associated with this fault, if any.
		Errors *[]struct {
			// Code The code associated with this error.
			Code *string `json:"code,omitempty"`

			// Field The specific field or aspect of the resource associated with this error.
			Field *string `json:"field,omitempty"`

			// Resource The type of resource associated with this error.
			Resource *string `json:"resource,omitempty"`
		} `json:"errors,omitempty"`

		// Message The message of the fault.
		Message *string `json:"message,omitempty"`
	}
}
type GetZonesByActivityId200Type string

// Status returns HTTPResponse.Status
func (r GetZonesByActivityIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetZonesByActivityIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLoggedInAthleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Bikes The athlete's bikes.
		Bikes *[]struct {
			// Distance The distance logged with this gear.
			Distance *float32 `json:"distance,omitempty"`

			// Id The gear's unique identifier.
			Id *string `json:"id,omitempty"`

			// Name The gear's name.
			Name *string `json:"name,omitempty"`

			// Primary Whether this gear's is the owner's default one.
			Primary *bool `json:"primary,omitempty"`

			// ResourceState Resource state, indicates level of detail. Possible values: 2 -> "summary", 3 -> "detail"
			ResourceState *int `json:"resource_state,omitempty"`
		} `json:"bikes,omitempty"`

		// City The athlete's city.
		City *string `json:"city,omitempty"`

		// Clubs The athlete's clubs.
		Clubs *[]struct {
			// ActivityTypes The activity types that count for a club. This takes precedence over sport_type.
			ActivityTypes *[]GetLoggedInAthlete200ClubsActivityTypes `json:"activity_types,omitempty"`

			// City The club's city.
			City *string `json:"city,omitempty"`

			// Country The club's country.
			Country *string `json:"country,omitempty"`

			// CoverPhoto URL to a ~1185x580 pixel cover photo.
			CoverPhoto *string `json:"cover_photo,omitempty"`

			// CoverPhotoSmall URL to a ~360x176  pixel cover photo.
			CoverPhotoSmall *string `json:"cover_photo_small,omitempty"`

			// Featured Whether the club is featured or not.
			Featured *bool `json:"featured,omitempty"`

			// Id The club's unique identifier.
			Id *int64 `json:"id,omitempty"`

			// MemberCount The club's member count.
			MemberCount *int `json:"member_count,omitempty"`

			// Name The club's name.
			Name *string `json:"name,omitempty"`

			// Private Whether the club is private.
			Private *bool `json:"private,omitempty"`

			// ProfileMedium URL to a 60x60 pixel profile picture.
			ProfileMedium *string `json:"profile_medium,omitempty"`

			// ResourceState Resource state, indicates level of detail. Possible values: 1 -> "meta", 2 -> "summary", 3 -> "detail"
			ResourceState *int `json:"resource_state,omitempty"`

			// SportType Deprecated. Prefer to use activity_types.
			SportType *GetLoggedInAthlete200ClubsSportType `json:"sport_type,omitempty"`

			// State The club's state or geographical region.
			State *string `json:"state,omitempty"`

			// Url The club's vanity URL.
			Url *string `json:"url,omitempty"`

			// Verified Whether the club is verified or not.
			Verified *bool `json:"verified,omitempty"`
		} `json:"clubs,omitempty"`

		// Country The athlete's country.
		Country *string `json:"country,omitempty"`

		// CreatedAt The time at which the athlete was created.
		CreatedAt *time.Time `json:"created_at,omitempty"`

		// Firstname The athlete's first name.
		Firstname *string `json:"firstname,omitempty"`

		// FollowerCount The athlete's follower count.
		FollowerCount *int `json:"follower_count,omitempty"`

		// FriendCount The athlete's friend count.
		FriendCount *int `json:"friend_count,omitempty"`

		// Ftp The athlete's FTP (Functional Threshold Power).
		Ftp *int `json:"ftp,omitempty"`

		// Id The unique identifier of the athlete
		Id *int64 `json:"id,omitempty"`

		// Lastname The athlete's last name.
		Lastname *string `json:"lastname,omitempty"`

		// MeasurementPreference The athlete's preferred unit system.
		MeasurementPreference *GetLoggedInAthlete200MeasurementPreference `json:"measurement_preference,omitempty"`

		// Premium Deprecated.  Use summit field instead. Whether the athlete has any Summit subscription.
		Premium *bool `json:"premium,omitempty"`

		// Profile URL to a 124x124 pixel profile picture.
		Profile *string `json:"profile,omitempty"`

		// ProfileMedium URL to a 62x62 pixel profile picture.
		ProfileMedium *string `json:"profile_medium,omitempty"`

		// ResourceState Resource state, indicates level of detail. Possible values: 1 -> "meta", 2 -> "summary", 3 -> "detail"
		ResourceState *int `json:"resource_state,omitempty"`

		// Sex The athlete's sex.
		Sex *GetLoggedInAthlete200Sex `json:"sex,omitempty"`

		// Shoes The athlete's shoes.
		Shoes *[]struct {
			// Distance The distance logged with this gear.
			Distance *float32 `json:"distance,omitempty"`

			// Id The gear's unique identifier.
			Id *string `json:"id,omitempty"`

			// Name The gear's name.
			Name *string `json:"name,omitempty"`

			// Primary Whether this gear's is the owner's default one.
			Primary *bool `json:"primary,omitempty"`

			// ResourceState Resource state, indicates level of detail. Possible values: 2 -> "summary", 3 -> "detail"
			ResourceState *int `json:"resource_state,omitempty"`
		} `json:"shoes,omitempty"`

		// State The athlete's state or geographical region.
		State *string `json:"state,omitempty"`

		// Summit Whether the athlete has any Summit subscription.
		Summit *bool `json:"summit,omitempty"`

		// UpdatedAt The time at which the athlete was last updated.
		UpdatedAt *time.Time `json:"updated_at,omitempty"`

		// Weight The athlete's weight.
		Weight *float32 `json:"weight,omitempty"`
	}
	JSONDefault *struct {
		// Errors The set of specific errors associated with this fault, if any.
		Errors *[]struct {
			// Code The code associated with this error.
			Code *string `json:"code,omitempty"`

			// Field The specific field or aspect of the resource associated with this error.
			Field *string `json:"field,omitempty"`

			// Resource The type of resource associated with this error.
			Resource *string `json:"resource,omitempty"`
		} `json:"errors,omitempty"`

		// Message The message of the fault.
		Message *string `json:"message,omitempty"`
	}
}
type GetLoggedInAthlete200ClubsActivityTypes string
type GetLoggedInAthlete200ClubsSportType string
type GetLoggedInAthlete200MeasurementPreference string
type GetLoggedInAthlete200Sex string

// Status returns HTTPResponse.Status
func (r GetLoggedInAthleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLoggedInAthleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLoggedInAthleteActivitiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		// AchievementCount The number of achievements gained during this activity
		AchievementCount *int `json:"achievement_count,omitempty"`
		Athlete          *struct {
			// Id The unique identifier of the athlete
			Id *int64 `json:"id,omitempty"`
		} `json:"athlete,omitempty"`

		// AthleteCount The number of athletes for taking part in a group activity
		AthleteCount *int `json:"athlete_count,omitempty"`

		// AverageSpeed The activity's average speed, in meters per second
		AverageSpeed *float32 `json:"average_speed,omitempty"`

		// AverageWatts Average power output in watts during this activity. Rides only
		AverageWatts *float32 `json:"average_watts,omitempty"`

		// CommentCount The number of comments for this activity
		CommentCount *int `json:"comment_count,omitempty"`

		// Commute Whether this activity is a commute
		Commute *bool `json:"commute,omitempty"`

		// DeviceName The name of the device used to record the activity
		DeviceName *string `json:"device_name,omitempty"`

		// DeviceWatts Whether the watts are from a power meter, false if estimated
		DeviceWatts *bool `json:"device_watts,omitempty"`

		// Distance The activity's distance, in meters
		Distance *float32 `json:"distance,omitempty"`

		// ElapsedTime The activity's elapsed time, in seconds
		ElapsedTime *int `json:"elapsed_time,omitempty"`

		// ElevHigh The activity's highest elevation, in meters
		ElevHigh *float32 `json:"elev_high,omitempty"`

		// ElevLow The activity's lowest elevation, in meters
		ElevLow *float32 `json:"elev_low,omitempty"`

		// EndLatlng A pair of latitude/longitude coordinates, represented as an array of 2 floating point numbers.
		EndLatlng *[]float32 `json:"end_latlng,omitempty"`

		// ExternalId The identifier provided at upload time
		ExternalId *string `json:"external_id,omitempty"`

		// Flagged Whether this activity is flagged
		Flagged *bool `json:"flagged,omitempty"`

		// GearId The id of the gear for the activity
		GearId *string `json:"gear_id,omitempty"`

		// HasKudoed Whether the logged-in athlete has kudoed this activity
		HasKudoed *bool `json:"has_kudoed,omitempty"`

		// HideFromHome Whether the activity is muted
		HideFromHome *bool `json:"hide_from_home,omitempty"`

		// Id The unique identifier of the activity
		Id *int64 `json:"id,omitempty"`

		// Kilojoules The total work done in kilojoules during this activity. Rides only
		Kilojoules *float32 `json:"kilojoules,omitempty"`

		// KudosCount The number of kudos given for this activity
		KudosCount *int `json:"kudos_count,omitempty"`

		// Manual Whether this activity was created manually
		Manual *bool `json:"manual,omitempty"`
		Map    *struct {
			// Id The identifier of the map
			Id *string `json:"id,omitempty"`

			// Polyline The polyline of the map, only returned on detailed representation of an object
			Polyline *string `json:"polyline,omitempty"`

			// SummaryPolyline The summary polyline of the map
			SummaryPolyline *string `json:"summary_polyline,omitempty"`
		} `json:"map,omitempty"`

		// MaxSpeed The activity's max speed, in meters per second
		MaxSpeed *float32 `json:"max_speed,omitempty"`

		// MaxWatts Rides with power meter data only
		MaxWatts *int `json:"max_watts,omitempty"`

		// MovingTime The activity's moving time, in seconds
		MovingTime *int `json:"moving_time,omitempty"`

		// Name The name of the activity
		Name *string `json:"name,omitempty"`

		// PhotoCount The number of Instagram photos for this activity
		PhotoCount *int `json:"photo_count,omitempty"`

		// Private Whether this activity is private
		Private *bool `json:"private,omitempty"`

		// SportType An enumeration of the sport types an activity may have. Distinct from ActivityType in that it has new types (e.g. MountainBikeRide)
		SportType *GetLoggedInAthleteActivities200SportType `json:"sport_type,omitempty"`

		// StartDate The time at which the activity was started.
		StartDate *time.Time `json:"start_date,omitempty"`

		// StartDateLocal The time at which the activity was started in the local timezone.
		StartDateLocal *time.Time `json:"start_date_local,omitempty"`

		// StartLatlng A pair of latitude/longitude coordinates, represented as an array of 2 floating point numbers.
		StartLatlng *[]float32 `json:"start_latlng,omitempty"`

		// Timezone The timezone of the activity
		Timezone *string `json:"timezone,omitempty"`

		// TotalElevationGain The activity's total elevation gain.
		TotalElevationGain *float32 `json:"total_elevation_gain,omitempty"`

		// TotalPhotoCount The number of Instagram and Strava photos for this activity
		TotalPhotoCount *int `json:"total_photo_count,omitempty"`

		// Trainer Whether this activity was recorded on a training machine
		Trainer *bool `json:"trainer,omitempty"`

		// Type Deprecated. Prefer to use sport_type
		Type *GetLoggedInAthleteActivities200Type `json:"type,omitempty"`

		// UploadId The identifier of the upload that resulted in this activity
		UploadId *int64 `json:"upload_id,omitempty"`

		// UploadIdStr The unique identifier of the upload in string format
		UploadIdStr *string `json:"upload_id_str,omitempty"`

		// WeightedAverageWatts Similar to Normalized Power. Rides with power meter data only
		WeightedAverageWatts *int `json:"weighted_average_watts,omitempty"`

		// WorkoutType The activity's workout type
		WorkoutType *int `json:"workout_type,omitempty"`
	}
	JSONDefault *struct {
		// Errors The set of specific errors associated with this fault, if any.
		Errors *[]struct {
			// Code The code associated with this error.
			Code *string `json:"code,omitempty"`

			// Field The specific field or aspect of the resource associated with this error.
			Field *string `json:"field,omitempty"`

			// Resource The type of resource associated with this error.
			Resource *string `json:"resource,omitempty"`
		} `json:"errors,omitempty"`

		// Message The message of the fault.
		Message *string `json:"message,omitempty"`
	}
}
type GetLoggedInAthleteActivities200SportType string
type GetLoggedInAthleteActivities200Type string

// Status returns HTTPResponse.Status
func (r GetLoggedInAthleteActivitiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLoggedInAthleteActivitiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLoggedInAthleteClubsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		// ActivityTypes The activity types that count for a club. This takes precedence over sport_type.
		ActivityTypes *[]GetLoggedInAthleteClubs200ActivityTypes `json:"activity_types,omitempty"`

		// City The club's city.
		City *string `json:"city,omitempty"`

		// Country The club's country.
		Country *string `json:"country,omitempty"`

		// CoverPhoto URL to a ~1185x580 pixel cover photo.
		CoverPhoto *string `json:"cover_photo,omitempty"`

		// CoverPhotoSmall URL to a ~360x176  pixel cover photo.
		CoverPhotoSmall *string `json:"cover_photo_small,omitempty"`

		// Featured Whether the club is featured or not.
		Featured *bool `json:"featured,omitempty"`

		// Id The club's unique identifier.
		Id *int64 `json:"id,omitempty"`

		// MemberCount The club's member count.
		MemberCount *int `json:"member_count,omitempty"`

		// Name The club's name.
		Name *string `json:"name,omitempty"`

		// Private Whether the club is private.
		Private *bool `json:"private,omitempty"`

		// ProfileMedium URL to a 60x60 pixel profile picture.
		ProfileMedium *string `json:"profile_medium,omitempty"`

		// ResourceState Resource state, indicates level of detail. Possible values: 1 -> "meta", 2 -> "summary", 3 -> "detail"
		ResourceState *int `json:"resource_state,omitempty"`

		// SportType Deprecated. Prefer to use activity_types.
		SportType *GetLoggedInAthleteClubs200SportType `json:"sport_type,omitempty"`

		// State The club's state or geographical region.
		State *string `json:"state,omitempty"`

		// Url The club's vanity URL.
		Url *string `json:"url,omitempty"`

		// Verified Whether the club is verified or not.
		Verified *bool `json:"verified,omitempty"`
	}
	JSONDefault *struct {
		// Errors The set of specific errors associated with this fault, if any.
		Errors *[]struct {
			// Code The code associated with this error.
			Code *string `json:"code,omitempty"`

			// Field The specific field or aspect of the resource associated with this error.
			Field *string `json:"field,omitempty"`

			// Resource The type of resource associated with this error.
			Resource *string `json:"resource,omitempty"`
		} `json:"errors,omitempty"`

		// Message The message of the fault.
		Message *string `json:"message,omitempty"`
	}
}
type GetLoggedInAthleteClubs200ActivityTypes string
type GetLoggedInAthleteClubs200SportType string

// Status returns HTTPResponse.Status
func (r GetLoggedInAthleteClubsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLoggedInAthleteClubsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLoggedInAthleteZonesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		HeartRate *struct {
			// CustomZones Whether the athlete has set their own custom heart rate zones
			CustomZones *bool `json:"custom_zones,omitempty"`
			Zones       *[]struct {
				// Max The maximum value in the range.
				Max *int `json:"max,omitempty"`

				// Min The minimum value in the range.
				Min *int `json:"min,omitempty"`
			} `json:"zones,omitempty"`
		} `json:"heart_rate,omitempty"`
		Power *struct {
			Zones *[]struct {
				// Max The maximum value in the range.
				Max *int `json:"max,omitempty"`

				// Min The minimum value in the range.
				Min *int `json:"min,omitempty"`
			} `json:"zones,omitempty"`
		} `json:"power,omitempty"`
	}
	JSONDefault *struct {
		// Errors The set of specific errors associated with this fault, if any.
		Errors *[]struct {
			// Code The code associated with this error.
			Code *string `json:"code,omitempty"`

			// Field The specific field or aspect of the resource associated with this error.
			Field *string `json:"field,omitempty"`

			// Resource The type of resource associated with this error.
			Resource *string `json:"resource,omitempty"`
		} `json:"errors,omitempty"`

		// Message The message of the fault.
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetLoggedInAthleteZonesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLoggedInAthleteZonesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRoutesByAthleteIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		Athlete *struct {
			// City The athlete's city.
			City *string `json:"city,omitempty"`

			// Country The athlete's country.
			Country *string `json:"country,omitempty"`

			// CreatedAt The time at which the athlete was created.
			CreatedAt *time.Time `json:"created_at,omitempty"`

			// Firstname The athlete's first name.
			Firstname *string `json:"firstname,omitempty"`

			// Id The unique identifier of the athlete
			Id *int64 `json:"id,omitempty"`

			// Lastname The athlete's last name.
			Lastname *string `json:"lastname,omitempty"`

			// Premium Deprecated.  Use summit field instead. Whether the athlete has any Summit subscription.
			Premium *bool `json:"premium,omitempty"`

			// Profile URL to a 124x124 pixel profile picture.
			Profile *string `json:"profile,omitempty"`

			// ProfileMedium URL to a 62x62 pixel profile picture.
			ProfileMedium *string `json:"profile_medium,omitempty"`

			// ResourceState Resource state, indicates level of detail. Possible values: 1 -> "meta", 2 -> "summary", 3 -> "detail"
			ResourceState *int `json:"resource_state,omitempty"`

			// Sex The athlete's sex.
			Sex *GetRoutesByAthleteId200AthleteSex `json:"sex,omitempty"`

			// State The athlete's state or geographical region.
			State *string `json:"state,omitempty"`

			// Summit Whether the athlete has any Summit subscription.
			Summit *bool `json:"summit,omitempty"`

			// UpdatedAt The time at which the athlete was last updated.
			UpdatedAt *time.Time `json:"updated_at,omitempty"`
		} `json:"athlete,omitempty"`

		// CreatedAt The time at which the route was created
		CreatedAt *time.Time `json:"created_at,omitempty"`

		// Description The description of the route
		Description *string `json:"description,omitempty"`

		// Distance The route's distance, in meters
		Distance *float32 `json:"distance,omitempty"`

		// ElevationGain The route's elevation gain.
		ElevationGain *float32 `json:"elevation_gain,omitempty"`

		// EstimatedMovingTime Estimated time in seconds for the authenticated athlete to complete route
		EstimatedMovingTime *int `json:"estimated_moving_time,omitempty"`

		// Id The unique identifier of this route
		Id *int64 `json:"id,omitempty"`

		// IdStr The unique identifier of the route in string format
		IdStr *string `json:"id_str,omitempty"`
		Map   *struct {
			// Id The identifier of the map
			Id *string `json:"id,omitempty"`

			// Polyline The polyline of the map, only returned on detailed representation of an object
			Polyline *string `json:"polyline,omitempty"`

			// SummaryPolyline The summary polyline of the map
			SummaryPolyline *string `json:"summary_polyline,omitempty"`
		} `json:"map,omitempty"`

		// Name The name of this route
		Name *string `json:"name,omitempty"`

		// Private Whether this route is private
		Private *bool `json:"private,omitempty"`

		// Segments The segments traversed by this route
		Segments *[]struct {
			ActivityType    *GetRoutesByAthleteId200SegmentsActivityType `json:"activity_type,omitempty"`
			AthletePrEffort *struct {
				// EffortCount Number of efforts by the authenticated athlete on this segment.
				EffortCount *int `json:"effort_count,omitempty"`

				// PrActivityId The unique identifier of the activity related to the PR effort.
				PrActivityId *int64 `json:"pr_activity_id,omitempty"`

				// PrDate The time at which the PR effort was started.
				PrDate *time.Time `json:"pr_date,omitempty"`

				// PrElapsedTime The elapsed time ot the PR effort.
				PrElapsedTime *int `json:"pr_elapsed_time,omitempty"`
			} `json:"athlete_pr_effort,omitempty"`
			AthleteSegmentStats *struct {
				// ActivityId The unique identifier of the activity related to this effort
				ActivityId *int64 `json:"activity_id,omitempty"`

				// Distance The effort's distance in meters
				Distance *float32 `json:"distance,omitempty"`

				// ElapsedTime The effort's elapsed time
				ElapsedTime *int `json:"elapsed_time,omitempty"`

				// Id The unique identifier of this effort
				Id *int64 `json:"id,omitempty"`

				// IsKom Whether this effort is the current best on the leaderboard
				IsKom *bool `json:"is_kom,omitempty"`

				// StartDate The time at which the effort was started.
				StartDate *time.Time `json:"start_date,omitempty"`

				// StartDateLocal The time at which the effort was started in the local timezone.
				StartDateLocal *time.Time `json:"start_date_local,omitempty"`
			} `json:"athlete_segment_stats,omitempty"`

			// AverageGrade The segment's average grade, in percents
			AverageGrade *float32 `json:"average_grade,omitempty"`

			// City The segments's city.
			City *string `json:"city,omitempty"`

			// ClimbCategory The category of the climb [0, 5]. Higher is harder ie. 5 is Hors catgorie, 0 is uncategorized in climb_category.
			ClimbCategory *int `json:"climb_category,omitempty"`

			// Country The segment's country.
			Country *string `json:"country,omitempty"`

			// Distance The segment's distance, in meters
			Distance *float32 `json:"distance,omitempty"`

			// ElevationHigh The segments's highest elevation, in meters
			ElevationHigh *float32 `json:"elevation_high,omitempty"`

			// ElevationLow The segments's lowest elevation, in meters
			ElevationLow *float32 `json:"elevation_low,omitempty"`

			// EndLatlng A pair of latitude/longitude coordinates, represented as an array of 2 floating point numbers.
			EndLatlng *[]float32 `json:"end_latlng,omitempty"`

			// Id The unique identifier of this segment
			Id *int64 `json:"id,omitempty"`

			// MaximumGrade The segments's maximum grade, in percents
			MaximumGrade *float32 `json:"maximum_grade,omitempty"`

			// Name The name of this segment
			Name *string `json:"name,omitempty"`

			// Private Whether this segment is private.
			Private *bool `json:"private,omitempty"`

			// StartLatlng A pair of latitude/longitude coordinates, represented as an array of 2 floating point numbers.
			StartLatlng *[]float32 `json:"start_latlng,omitempty"`

			// State The segments's state or geographical region.
			State *string `json:"state,omitempty"`
		} `json:"segments,omitempty"`

		// Starred Whether this route is starred by the logged-in athlete
		Starred *bool `json:"starred,omitempty"`

		// SubType This route's sub-type (1 for road, 2 for mountain bike, 3 for cross, 4 for trail, 5 for mixed)
		SubType *int `json:"sub_type,omitempty"`

		// Timestamp An epoch timestamp of when the route was created
		Timestamp *int `json:"timestamp,omitempty"`

		// Type This route's type (1 for ride, 2 for runs)
		Type *int `json:"type,omitempty"`

		// UpdatedAt The time at which the route was last updated
		UpdatedAt *time.Time `json:"updated_at,omitempty"`

		// Waypoints The custom waypoints along this route
		Waypoints *[]struct {
			// Categories Categories that the waypoint belongs to
			Categories *[]string `json:"categories,omitempty"`

			// Description A description of the waypoint (optional)
			Description *string `json:"description,omitempty"`

			// DistanceIntoRoute The number meters along the route that the waypoint is located
			DistanceIntoRoute *float32 `json:"distance_into_route,omitempty"`

			// Latlng The location along the route that the waypoint is closest to
			Latlng *[]float32 `json:"latlng,omitempty"`

			// TargetLatlng A location off of the route that the waypoint is (optional)
			TargetLatlng *[]float32 `json:"target_latlng,omitempty"`

			// Title A title for the waypoint
			Title *string `json:"title,omitempty"`
		} `json:"waypoints,omitempty"`
	}
	JSONDefault *struct {
		// Errors The set of specific errors associated with this fault, if any.
		Errors *[]struct {
			// Code The code associated with this error.
			Code *string `json:"code,omitempty"`

			// Field The specific field or aspect of the resource associated with this error.
			Field *string `json:"field,omitempty"`

			// Resource The type of resource associated with this error.
			Resource *string `json:"resource,omitempty"`
		} `json:"errors,omitempty"`

		// Message The message of the fault.
		Message *string `json:"message,omitempty"`
	}
}
type GetRoutesByAthleteId200AthleteSex string
type GetRoutesByAthleteId200SegmentsActivityType string

// Status returns HTTPResponse.Status
func (r GetRoutesByAthleteIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRoutesByAthleteIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStatsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AllRideTotals The all time ride stats for the athlete.
		AllRideTotals *struct {
			// AchievementCount The total number of achievements of the considered activities.
			AchievementCount *int `json:"achievement_count,omitempty"`

			// Count The number of activities considered in this total.
			Count *int `json:"count,omitempty"`

			// Distance The total distance covered by the considered activities.
			Distance *float32 `json:"distance,omitempty"`

			// ElapsedTime The total elapsed time of the considered activities.
			ElapsedTime *int `json:"elapsed_time,omitempty"`

			// ElevationGain The total elevation gain of the considered activities.
			ElevationGain *float32 `json:"elevation_gain,omitempty"`

			// MovingTime The total moving time of the considered activities.
			MovingTime *int `json:"moving_time,omitempty"`
		} `json:"all_ride_totals,omitempty"`

		// AllRunTotals The all time run stats for the athlete.
		AllRunTotals *struct {
			// AchievementCount The total number of achievements of the considered activities.
			AchievementCount *int `json:"achievement_count,omitempty"`

			// Count The number of activities considered in this total.
			Count *int `json:"count,omitempty"`

			// Distance The total distance covered by the considered activities.
			Distance *float32 `json:"distance,omitempty"`

			// ElapsedTime The total elapsed time of the considered activities.
			ElapsedTime *int `json:"elapsed_time,omitempty"`

			// ElevationGain The total elevation gain of the considered activities.
			ElevationGain *float32 `json:"elevation_gain,omitempty"`

			// MovingTime The total moving time of the considered activities.
			MovingTime *int `json:"moving_time,omitempty"`
		} `json:"all_run_totals,omitempty"`

		// AllSwimTotals The all time swim stats for the athlete.
		AllSwimTotals *struct {
			// AchievementCount The total number of achievements of the considered activities.
			AchievementCount *int `json:"achievement_count,omitempty"`

			// Count The number of activities considered in this total.
			Count *int `json:"count,omitempty"`

			// Distance The total distance covered by the considered activities.
			Distance *float32 `json:"distance,omitempty"`

			// ElapsedTime The total elapsed time of the considered activities.
			ElapsedTime *int `json:"elapsed_time,omitempty"`

			// ElevationGain The total elevation gain of the considered activities.
			ElevationGain *float32 `json:"elevation_gain,omitempty"`

			// MovingTime The total moving time of the considered activities.
			MovingTime *int `json:"moving_time,omitempty"`
		} `json:"all_swim_totals,omitempty"`

		// BiggestClimbElevationGain The highest climb ridden by the athlete.
		BiggestClimbElevationGain *float64 `json:"biggest_climb_elevation_gain,omitempty"`

		// BiggestRideDistance The longest distance ridden by the athlete.
		BiggestRideDistance *float64 `json:"biggest_ride_distance,omitempty"`

		// RecentRideTotals The recent (last 4 weeks) ride stats for the athlete.
		RecentRideTotals *struct {
			// AchievementCount The total number of achievements of the considered activities.
			AchievementCount *int `json:"achievement_count,omitempty"`

			// Count The number of activities considered in this total.
			Count *int `json:"count,omitempty"`

			// Distance The total distance covered by the considered activities.
			Distance *float32 `json:"distance,omitempty"`

			// ElapsedTime The total elapsed time of the considered activities.
			ElapsedTime *int `json:"elapsed_time,omitempty"`

			// ElevationGain The total elevation gain of the considered activities.
			ElevationGain *float32 `json:"elevation_gain,omitempty"`

			// MovingTime The total moving time of the considered activities.
			MovingTime *int `json:"moving_time,omitempty"`
		} `json:"recent_ride_totals,omitempty"`

		// RecentRunTotals The recent (last 4 weeks) run stats for the athlete.
		RecentRunTotals *struct {
			// AchievementCount The total number of achievements of the considered activities.
			AchievementCount *int `json:"achievement_count,omitempty"`

			// Count The number of activities considered in this total.
			Count *int `json:"count,omitempty"`

			// Distance The total distance covered by the considered activities.
			Distance *float32 `json:"distance,omitempty"`

			// ElapsedTime The total elapsed time of the considered activities.
			ElapsedTime *int `json:"elapsed_time,omitempty"`

			// ElevationGain The total elevation gain of the considered activities.
			ElevationGain *float32 `json:"elevation_gain,omitempty"`

			// MovingTime The total moving time of the considered activities.
			MovingTime *int `json:"moving_time,omitempty"`
		} `json:"recent_run_totals,omitempty"`

		// RecentSwimTotals The recent (last 4 weeks) swim stats for the athlete.
		RecentSwimTotals *struct {
			// AchievementCount The total number of achievements of the considered activities.
			AchievementCount *int `json:"achievement_count,omitempty"`

			// Count The number of activities considered in this total.
			Count *int `json:"count,omitempty"`

			// Distance The total distance covered by the considered activities.
			Distance *float32 `json:"distance,omitempty"`

			// ElapsedTime The total elapsed time of the considered activities.
			ElapsedTime *int `json:"elapsed_time,omitempty"`

			// ElevationGain The total elevation gain of the considered activities.
			ElevationGain *float32 `json:"elevation_gain,omitempty"`

			// MovingTime The total moving time of the considered activities.
			MovingTime *int `json:"moving_time,omitempty"`
		} `json:"recent_swim_totals,omitempty"`

		// YtdRideTotals The year to date ride stats for the athlete.
		YtdRideTotals *struct {
			// AchievementCount The total number of achievements of the considered activities.
			AchievementCount *int `json:"achievement_count,omitempty"`

			// Count The number of activities considered in this total.
			Count *int `json:"count,omitempty"`

			// Distance The total distance covered by the considered activities.
			Distance *float32 `json:"distance,omitempty"`

			// ElapsedTime The total elapsed time of the considered activities.
			ElapsedTime *int `json:"elapsed_time,omitempty"`

			// ElevationGain The total elevation gain of the considered activities.
			ElevationGain *float32 `json:"elevation_gain,omitempty"`

			// MovingTime The total moving time of the considered activities.
			MovingTime *int `json:"moving_time,omitempty"`
		} `json:"ytd_ride_totals,omitempty"`

		// YtdRunTotals The year to date run stats for the athlete.
		YtdRunTotals *struct {
			// AchievementCount The total number of achievements of the considered activities.
			AchievementCount *int `json:"achievement_count,omitempty"`

			// Count The number of activities considered in this total.
			Count *int `json:"count,omitempty"`

			// Distance The total distance covered by the considered activities.
			Distance *float32 `json:"distance,omitempty"`

			// ElapsedTime The total elapsed time of the considered activities.
			ElapsedTime *int `json:"elapsed_time,omitempty"`

			// ElevationGain The total elevation gain of the considered activities.
			ElevationGain *float32 `json:"elevation_gain,omitempty"`

			// MovingTime The total moving time of the considered activities.
			MovingTime *int `json:"moving_time,omitempty"`
		} `json:"ytd_run_totals,omitempty"`

		// YtdSwimTotals The year to date swim stats for the athlete.
		YtdSwimTotals *struct {
			// AchievementCount The total number of achievements of the considered activities.
			AchievementCount *int `json:"achievement_count,omitempty"`

			// Count The number of activities considered in this total.
			Count *int `json:"count,omitempty"`

			// Distance The total distance covered by the considered activities.
			Distance *float32 `json:"distance,omitempty"`

			// ElapsedTime The total elapsed time of the considered activities.
			ElapsedTime *int `json:"elapsed_time,omitempty"`

			// ElevationGain The total elevation gain of the considered activities.
			ElevationGain *float32 `json:"elevation_gain,omitempty"`

			// MovingTime The total moving time of the considered activities.
			MovingTime *int `json:"moving_time,omitempty"`
		} `json:"ytd_swim_totals,omitempty"`
	}
	JSONDefault *struct {
		// Errors The set of specific errors associated with this fault, if any.
		Errors *[]struct {
			// Code The code associated with this error.
			Code *string `json:"code,omitempty"`

			// Field The specific field or aspect of the resource associated with this error.
			Field *string `json:"field,omitempty"`

			// Resource The type of resource associated with this error.
			Resource *string `json:"resource,omitempty"`
		} `json:"errors,omitempty"`

		// Message The message of the fault.
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetStatsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStatsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClubByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// ActivityTypes The activity types that count for a club. This takes precedence over sport_type.
		ActivityTypes *[]GetClubById200ActivityTypes `json:"activity_types,omitempty"`

		// Admin Whether the currently logged-in athlete is an administrator of this club.
		Admin *bool `json:"admin,omitempty"`

		// City The club's city.
		City *string `json:"city,omitempty"`

		// Country The club's country.
		Country *string `json:"country,omitempty"`

		// CoverPhoto URL to a ~1185x580 pixel cover photo.
		CoverPhoto *string `json:"cover_photo,omitempty"`

		// CoverPhotoSmall URL to a ~360x176  pixel cover photo.
		CoverPhotoSmall *string `json:"cover_photo_small,omitempty"`

		// Featured Whether the club is featured or not.
		Featured *bool `json:"featured,omitempty"`

		// FollowingCount The number of athletes in the club that the logged-in athlete follows.
		FollowingCount *int `json:"following_count,omitempty"`

		// Id The club's unique identifier.
		Id *int64 `json:"id,omitempty"`

		// MemberCount The club's member count.
		MemberCount *int `json:"member_count,omitempty"`

		// Membership The membership status of the logged-in athlete.
		Membership *GetClubById200Membership `json:"membership,omitempty"`

		// Name The club's name.
		Name *string `json:"name,omitempty"`

		// Owner Whether the currently logged-in athlete is the owner of this club.
		Owner *bool `json:"owner,omitempty"`

		// Private Whether the club is private.
		Private *bool `json:"private,omitempty"`

		// ProfileMedium URL to a 60x60 pixel profile picture.
		ProfileMedium *string `json:"profile_medium,omitempty"`

		// ResourceState Resource state, indicates level of detail. Possible values: 1 -> "meta", 2 -> "summary", 3 -> "detail"
		ResourceState *int `json:"resource_state,omitempty"`

		// SportType Deprecated. Prefer to use activity_types.
		SportType *GetClubById200SportType `json:"sport_type,omitempty"`

		// State The club's state or geographical region.
		State *string `json:"state,omitempty"`

		// Url The club's vanity URL.
		Url *string `json:"url,omitempty"`

		// Verified Whether the club is verified or not.
		Verified *bool `json:"verified,omitempty"`
	}
	JSONDefault *struct {
		// Errors The set of specific errors associated with this fault, if any.
		Errors *[]struct {
			// Code The code associated with this error.
			Code *string `json:"code,omitempty"`

			// Field The specific field or aspect of the resource associated with this error.
			Field *string `json:"field,omitempty"`

			// Resource The type of resource associated with this error.
			Resource *string `json:"resource,omitempty"`
		} `json:"errors,omitempty"`

		// Message The message of the fault.
		Message *string `json:"message,omitempty"`
	}
}
type GetClubById200ActivityTypes string
type GetClubById200Membership string
type GetClubById200SportType string

// Status returns HTTPResponse.Status
func (r GetClubByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClubByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClubActivitiesByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		Athlete *struct {
			// Id The unique identifier of the athlete
			Id *int64 `json:"id,omitempty"`
		} `json:"athlete,omitempty"`

		// Distance The activity's distance, in meters
		Distance *float32 `json:"distance,omitempty"`

		// ElapsedTime The activity's elapsed time, in seconds
		ElapsedTime *int `json:"elapsed_time,omitempty"`

		// MovingTime The activity's moving time, in seconds
		MovingTime *int `json:"moving_time,omitempty"`

		// Name The name of the activity
		Name *string `json:"name,omitempty"`

		// SportType An enumeration of the sport types an activity may have. Distinct from ActivityType in that it has new types (e.g. MountainBikeRide)
		SportType *GetClubActivitiesById200SportType `json:"sport_type,omitempty"`

		// TotalElevationGain The activity's total elevation gain.
		TotalElevationGain *float32 `json:"total_elevation_gain,omitempty"`

		// Type Deprecated. Prefer to use sport_type
		Type *GetClubActivitiesById200Type `json:"type,omitempty"`

		// WorkoutType The activity's workout type
		WorkoutType *int `json:"workout_type,omitempty"`
	}
	JSONDefault *struct {
		// Errors The set of specific errors associated with this fault, if any.
		Errors *[]struct {
			// Code The code associated with this error.
			Code *string `json:"code,omitempty"`

			// Field The specific field or aspect of the resource associated with this error.
			Field *string `json:"field,omitempty"`

			// Resource The type of resource associated with this error.
			Resource *string `json:"resource,omitempty"`
		} `json:"errors,omitempty"`

		// Message The message of the fault.
		Message *string `json:"message,omitempty"`
	}
}
type GetClubActivitiesById200SportType string
type GetClubActivitiesById200Type string

// Status returns HTTPResponse.Status
func (r GetClubActivitiesByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClubActivitiesByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClubMembersByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		// Admin Whether the athlete is a club admin.
		Admin *bool `json:"admin,omitempty"`

		// Firstname The athlete's first name.
		Firstname *string `json:"firstname,omitempty"`

		// Lastname The athlete's last initial.
		Lastname *string `json:"lastname,omitempty"`

		// Member The athlete's member status.
		Member *string `json:"member,omitempty"`

		// Owner Whether the athlete is club owner.
		Owner *bool `json:"owner,omitempty"`

		// ResourceState Resource state, indicates level of detail. Possible values: 1 -> "meta", 2 -> "summary", 3 -> "detail"
		ResourceState *int `json:"resource_state,omitempty"`
	}
	JSONDefault *struct {
		// Errors The set of specific errors associated with this fault, if any.
		Errors *[]struct {
			// Code The code associated with this error.
			Code *string `json:"code,omitempty"`

			// Field The specific field or aspect of the resource associated with this error.
			Field *string `json:"field,omitempty"`

			// Resource The type of resource associated with this error.
			Resource *string `json:"resource,omitempty"`
		} `json:"errors,omitempty"`

		// Message The message of the fault.
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetClubMembersByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClubMembersByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGearByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// BrandName The gear's brand name.
		BrandName *string `json:"brand_name,omitempty"`

		// Description The gear's description.
		Description *string `json:"description,omitempty"`

		// Distance The distance logged with this gear.
		Distance *float32 `json:"distance,omitempty"`

		// FrameType The gear's frame type (bike only).
		FrameType *int `json:"frame_type,omitempty"`

		// Id The gear's unique identifier.
		Id *string `json:"id,omitempty"`

		// ModelName The gear's model name.
		ModelName *string `json:"model_name,omitempty"`

		// Name The gear's name.
		Name *string `json:"name,omitempty"`

		// Primary Whether this gear's is the owner's default one.
		Primary *bool `json:"primary,omitempty"`

		// ResourceState Resource state, indicates level of detail. Possible values: 2 -> "summary", 3 -> "detail"
		ResourceState *int `json:"resource_state,omitempty"`
	}
	JSONDefault *struct {
		// Errors The set of specific errors associated with this fault, if any.
		Errors *[]struct {
			// Code The code associated with this error.
			Code *string `json:"code,omitempty"`

			// Field The specific field or aspect of the resource associated with this error.
			Field *string `json:"field,omitempty"`

			// Resource The type of resource associated with this error.
			Resource *string `json:"resource,omitempty"`
		} `json:"errors,omitempty"`

		// Message The message of the fault.
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetGearByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGearByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRouteByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Athlete *struct {
			// City The athlete's city.
			City *string `json:"city,omitempty"`

			// Country The athlete's country.
			Country *string `json:"country,omitempty"`

			// CreatedAt The time at which the athlete was created.
			CreatedAt *time.Time `json:"created_at,omitempty"`

			// Firstname The athlete's first name.
			Firstname *string `json:"firstname,omitempty"`

			// Id The unique identifier of the athlete
			Id *int64 `json:"id,omitempty"`

			// Lastname The athlete's last name.
			Lastname *string `json:"lastname,omitempty"`

			// Premium Deprecated.  Use summit field instead. Whether the athlete has any Summit subscription.
			Premium *bool `json:"premium,omitempty"`

			// Profile URL to a 124x124 pixel profile picture.
			Profile *string `json:"profile,omitempty"`

			// ProfileMedium URL to a 62x62 pixel profile picture.
			ProfileMedium *string `json:"profile_medium,omitempty"`

			// ResourceState Resource state, indicates level of detail. Possible values: 1 -> "meta", 2 -> "summary", 3 -> "detail"
			ResourceState *int `json:"resource_state,omitempty"`

			// Sex The athlete's sex.
			Sex *GetRouteById200AthleteSex `json:"sex,omitempty"`

			// State The athlete's state or geographical region.
			State *string `json:"state,omitempty"`

			// Summit Whether the athlete has any Summit subscription.
			Summit *bool `json:"summit,omitempty"`

			// UpdatedAt The time at which the athlete was last updated.
			UpdatedAt *time.Time `json:"updated_at,omitempty"`
		} `json:"athlete,omitempty"`

		// CreatedAt The time at which the route was created
		CreatedAt *time.Time `json:"created_at,omitempty"`

		// Description The description of the route
		Description *string `json:"description,omitempty"`

		// Distance The route's distance, in meters
		Distance *float32 `json:"distance,omitempty"`

		// ElevationGain The route's elevation gain.
		ElevationGain *float32 `json:"elevation_gain,omitempty"`

		// EstimatedMovingTime Estimated time in seconds for the authenticated athlete to complete route
		EstimatedMovingTime *int `json:"estimated_moving_time,omitempty"`

		// Id The unique identifier of this route
		Id *int64 `json:"id,omitempty"`

		// IdStr The unique identifier of the route in string format
		IdStr *string `json:"id_str,omitempty"`
		Map   *struct {
			// Id The identifier of the map
			Id *string `json:"id,omitempty"`

			// Polyline The polyline of the map, only returned on detailed representation of an object
			Polyline *string `json:"polyline,omitempty"`

			// SummaryPolyline The summary polyline of the map
			SummaryPolyline *string `json:"summary_polyline,omitempty"`
		} `json:"map,omitempty"`

		// Name The name of this route
		Name *string `json:"name,omitempty"`

		// Private Whether this route is private
		Private *bool `json:"private,omitempty"`

		// Segments The segments traversed by this route
		Segments *[]struct {
			ActivityType    *GetRouteById200SegmentsActivityType `json:"activity_type,omitempty"`
			AthletePrEffort *struct {
				// EffortCount Number of efforts by the authenticated athlete on this segment.
				EffortCount *int `json:"effort_count,omitempty"`

				// PrActivityId The unique identifier of the activity related to the PR effort.
				PrActivityId *int64 `json:"pr_activity_id,omitempty"`

				// PrDate The time at which the PR effort was started.
				PrDate *time.Time `json:"pr_date,omitempty"`

				// PrElapsedTime The elapsed time ot the PR effort.
				PrElapsedTime *int `json:"pr_elapsed_time,omitempty"`
			} `json:"athlete_pr_effort,omitempty"`
			AthleteSegmentStats *struct {
				// ActivityId The unique identifier of the activity related to this effort
				ActivityId *int64 `json:"activity_id,omitempty"`

				// Distance The effort's distance in meters
				Distance *float32 `json:"distance,omitempty"`

				// ElapsedTime The effort's elapsed time
				ElapsedTime *int `json:"elapsed_time,omitempty"`

				// Id The unique identifier of this effort
				Id *int64 `json:"id,omitempty"`

				// IsKom Whether this effort is the current best on the leaderboard
				IsKom *bool `json:"is_kom,omitempty"`

				// StartDate The time at which the effort was started.
				StartDate *time.Time `json:"start_date,omitempty"`

				// StartDateLocal The time at which the effort was started in the local timezone.
				StartDateLocal *time.Time `json:"start_date_local,omitempty"`
			} `json:"athlete_segment_stats,omitempty"`

			// AverageGrade The segment's average grade, in percents
			AverageGrade *float32 `json:"average_grade,omitempty"`

			// City The segments's city.
			City *string `json:"city,omitempty"`

			// ClimbCategory The category of the climb [0, 5]. Higher is harder ie. 5 is Hors catgorie, 0 is uncategorized in climb_category.
			ClimbCategory *int `json:"climb_category,omitempty"`

			// Country The segment's country.
			Country *string `json:"country,omitempty"`

			// Distance The segment's distance, in meters
			Distance *float32 `json:"distance,omitempty"`

			// ElevationHigh The segments's highest elevation, in meters
			ElevationHigh *float32 `json:"elevation_high,omitempty"`

			// ElevationLow The segments's lowest elevation, in meters
			ElevationLow *float32 `json:"elevation_low,omitempty"`

			// EndLatlng A pair of latitude/longitude coordinates, represented as an array of 2 floating point numbers.
			EndLatlng *[]float32 `json:"end_latlng,omitempty"`

			// Id The unique identifier of this segment
			Id *int64 `json:"id,omitempty"`

			// MaximumGrade The segments's maximum grade, in percents
			MaximumGrade *float32 `json:"maximum_grade,omitempty"`

			// Name The name of this segment
			Name *string `json:"name,omitempty"`

			// Private Whether this segment is private.
			Private *bool `json:"private,omitempty"`

			// StartLatlng A pair of latitude/longitude coordinates, represented as an array of 2 floating point numbers.
			StartLatlng *[]float32 `json:"start_latlng,omitempty"`

			// State The segments's state or geographical region.
			State *string `json:"state,omitempty"`
		} `json:"segments,omitempty"`

		// Starred Whether this route is starred by the logged-in athlete
		Starred *bool `json:"starred,omitempty"`

		// SubType This route's sub-type (1 for road, 2 for mountain bike, 3 for cross, 4 for trail, 5 for mixed)
		SubType *int `json:"sub_type,omitempty"`

		// Timestamp An epoch timestamp of when the route was created
		Timestamp *int `json:"timestamp,omitempty"`

		// Type This route's type (1 for ride, 2 for runs)
		Type *int `json:"type,omitempty"`

		// UpdatedAt The time at which the route was last updated
		UpdatedAt *time.Time `json:"updated_at,omitempty"`

		// Waypoints The custom waypoints along this route
		Waypoints *[]struct {
			// Categories Categories that the waypoint belongs to
			Categories *[]string `json:"categories,omitempty"`

			// Description A description of the waypoint (optional)
			Description *string `json:"description,omitempty"`

			// DistanceIntoRoute The number meters along the route that the waypoint is located
			DistanceIntoRoute *float32 `json:"distance_into_route,omitempty"`

			// Latlng The location along the route that the waypoint is closest to
			Latlng *[]float32 `json:"latlng,omitempty"`

			// TargetLatlng A location off of the route that the waypoint is (optional)
			TargetLatlng *[]float32 `json:"target_latlng,omitempty"`

			// Title A title for the waypoint
			Title *string `json:"title,omitempty"`
		} `json:"waypoints,omitempty"`
	}
	JSONDefault *struct {
		// Errors The set of specific errors associated with this fault, if any.
		Errors *[]struct {
			// Code The code associated with this error.
			Code *string `json:"code,omitempty"`

			// Field The specific field or aspect of the resource associated with this error.
			Field *string `json:"field,omitempty"`

			// Resource The type of resource associated with this error.
			Resource *string `json:"resource,omitempty"`
		} `json:"errors,omitempty"`

		// Message The message of the fault.
		Message *string `json:"message,omitempty"`
	}
}
type GetRouteById200AthleteSex string
type GetRouteById200SegmentsActivityType string

// Status returns HTTPResponse.Status
func (r GetRouteByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRouteByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEffortsBySegmentIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		Activity *struct {
			// Id The unique identifier of the activity
			Id *int64 `json:"id,omitempty"`
		} `json:"activity,omitempty"`

		// ActivityId The unique identifier of the activity related to this effort
		ActivityId *int64 `json:"activity_id,omitempty"`
		Athlete    *struct {
			// Id The unique identifier of the athlete
			Id *int64 `json:"id,omitempty"`
		} `json:"athlete,omitempty"`

		// AverageCadence The effort's average cadence
		AverageCadence *float32 `json:"average_cadence,omitempty"`

		// AverageHeartrate The heart heart rate of the athlete during this effort
		AverageHeartrate *float32 `json:"average_heartrate,omitempty"`

		// AverageWatts The average wattage of this effort
		AverageWatts *float32 `json:"average_watts,omitempty"`

		// DeviceWatts For riding efforts, whether the wattage was reported by a dedicated recording device
		DeviceWatts *bool `json:"device_watts,omitempty"`

		// Distance The effort's distance in meters
		Distance *float32 `json:"distance,omitempty"`

		// ElapsedTime The effort's elapsed time
		ElapsedTime *int `json:"elapsed_time,omitempty"`

		// EndIndex The end index of this effort in its activity's stream
		EndIndex *int `json:"end_index,omitempty"`

		// Hidden Whether this effort should be hidden when viewed within an activity
		Hidden *bool `json:"hidden,omitempty"`

		// Id The unique identifier of this effort
		Id *int64 `json:"id,omitempty"`

		// IsKom Whether this effort is the current best on the leaderboard
		IsKom *bool `json:"is_kom,omitempty"`

		// KomRank The rank of the effort on the global leaderboard if it belongs in the top 10 at the time of upload
		KomRank *int `json:"kom_rank,omitempty"`

		// MaxHeartrate The maximum heart rate of the athlete during this effort
		MaxHeartrate *float32 `json:"max_heartrate,omitempty"`

		// MovingTime The effort's moving time
		MovingTime *int `json:"moving_time,omitempty"`

		// Name The name of the segment on which this effort was performed
		Name *string `json:"name,omitempty"`

		// PrRank The rank of the effort on the athlete's leaderboard if it belongs in the top 3 at the time of upload
		PrRank  *int `json:"pr_rank,omitempty"`
		Segment *struct {
			ActivityType    *GetEffortsBySegmentId200SegmentActivityType `json:"activity_type,omitempty"`
			AthletePrEffort *struct {
				// EffortCount Number of efforts by the authenticated athlete on this segment.
				EffortCount *int `json:"effort_count,omitempty"`

				// PrActivityId The unique identifier of the activity related to the PR effort.
				PrActivityId *int64 `json:"pr_activity_id,omitempty"`

				// PrDate The time at which the PR effort was started.
				PrDate *time.Time `json:"pr_date,omitempty"`

				// PrElapsedTime The elapsed time ot the PR effort.
				PrElapsedTime *int `json:"pr_elapsed_time,omitempty"`
			} `json:"athlete_pr_effort,omitempty"`
			AthleteSegmentStats *struct {
				// ActivityId The unique identifier of the activity related to this effort
				ActivityId *int64 `json:"activity_id,omitempty"`

				// Distance The effort's distance in meters
				Distance *float32 `json:"distance,omitempty"`

				// ElapsedTime The effort's elapsed time
				ElapsedTime *int `json:"elapsed_time,omitempty"`

				// Id The unique identifier of this effort
				Id *int64 `json:"id,omitempty"`

				// IsKom Whether this effort is the current best on the leaderboard
				IsKom *bool `json:"is_kom,omitempty"`

				// StartDate The time at which the effort was started.
				StartDate *time.Time `json:"start_date,omitempty"`

				// StartDateLocal The time at which the effort was started in the local timezone.
				StartDateLocal *time.Time `json:"start_date_local,omitempty"`
			} `json:"athlete_segment_stats,omitempty"`

			// AverageGrade The segment's average grade, in percents
			AverageGrade *float32 `json:"average_grade,omitempty"`

			// City The segments's city.
			City *string `json:"city,omitempty"`

			// ClimbCategory The category of the climb [0, 5]. Higher is harder ie. 5 is Hors catgorie, 0 is uncategorized in climb_category.
			ClimbCategory *int `json:"climb_category,omitempty"`

			// Country The segment's country.
			Country *string `json:"country,omitempty"`

			// Distance The segment's distance, in meters
			Distance *float32 `json:"distance,omitempty"`

			// ElevationHigh The segments's highest elevation, in meters
			ElevationHigh *float32 `json:"elevation_high,omitempty"`

			// ElevationLow The segments's lowest elevation, in meters
			ElevationLow *float32 `json:"elevation_low,omitempty"`

			// EndLatlng A pair of latitude/longitude coordinates, represented as an array of 2 floating point numbers.
			EndLatlng *[]float32 `json:"end_latlng,omitempty"`

			// Id The unique identifier of this segment
			Id *int64 `json:"id,omitempty"`

			// MaximumGrade The segments's maximum grade, in percents
			MaximumGrade *float32 `json:"maximum_grade,omitempty"`

			// Name The name of this segment
			Name *string `json:"name,omitempty"`

			// Private Whether this segment is private.
			Private *bool `json:"private,omitempty"`

			// StartLatlng A pair of latitude/longitude coordinates, represented as an array of 2 floating point numbers.
			StartLatlng *[]float32 `json:"start_latlng,omitempty"`

			// State The segments's state or geographical region.
			State *string `json:"state,omitempty"`
		} `json:"segment,omitempty"`

		// StartDate The time at which the effort was started.
		StartDate *time.Time `json:"start_date,omitempty"`

		// StartDateLocal The time at which the effort was started in the local timezone.
		StartDateLocal *time.Time `json:"start_date_local,omitempty"`

		// StartIndex The start index of this effort in its activity's stream
		StartIndex *int `json:"start_index,omitempty"`
	}
	JSONDefault *struct {
		// Errors The set of specific errors associated with this fault, if any.
		Errors *[]struct {
			// Code The code associated with this error.
			Code *string `json:"code,omitempty"`

			// Field The specific field or aspect of the resource associated with this error.
			Field *string `json:"field,omitempty"`

			// Resource The type of resource associated with this error.
			Resource *string `json:"resource,omitempty"`
		} `json:"errors,omitempty"`

		// Message The message of the fault.
		Message *string `json:"message,omitempty"`
	}
}
type GetEffortsBySegmentId200SegmentActivityType string

// Status returns HTTPResponse.Status
func (r GetEffortsBySegmentIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEffortsBySegmentIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSegmentEffortByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Activity *struct {
			// Id The unique identifier of the activity
			Id *int64 `json:"id,omitempty"`
		} `json:"activity,omitempty"`

		// ActivityId The unique identifier of the activity related to this effort
		ActivityId *int64 `json:"activity_id,omitempty"`
		Athlete    *struct {
			// Id The unique identifier of the athlete
			Id *int64 `json:"id,omitempty"`
		} `json:"athlete,omitempty"`

		// AverageCadence The effort's average cadence
		AverageCadence *float32 `json:"average_cadence,omitempty"`

		// AverageHeartrate The heart heart rate of the athlete during this effort
		AverageHeartrate *float32 `json:"average_heartrate,omitempty"`

		// AverageWatts The average wattage of this effort
		AverageWatts *float32 `json:"average_watts,omitempty"`

		// DeviceWatts For riding efforts, whether the wattage was reported by a dedicated recording device
		DeviceWatts *bool `json:"device_watts,omitempty"`

		// Distance The effort's distance in meters
		Distance *float32 `json:"distance,omitempty"`

		// ElapsedTime The effort's elapsed time
		ElapsedTime *int `json:"elapsed_time,omitempty"`

		// EndIndex The end index of this effort in its activity's stream
		EndIndex *int `json:"end_index,omitempty"`

		// Hidden Whether this effort should be hidden when viewed within an activity
		Hidden *bool `json:"hidden,omitempty"`

		// Id The unique identifier of this effort
		Id *int64 `json:"id,omitempty"`

		// IsKom Whether this effort is the current best on the leaderboard
		IsKom *bool `json:"is_kom,omitempty"`

		// KomRank The rank of the effort on the global leaderboard if it belongs in the top 10 at the time of upload
		KomRank *int `json:"kom_rank,omitempty"`

		// MaxHeartrate The maximum heart rate of the athlete during this effort
		MaxHeartrate *float32 `json:"max_heartrate,omitempty"`

		// MovingTime The effort's moving time
		MovingTime *int `json:"moving_time,omitempty"`

		// Name The name of the segment on which this effort was performed
		Name *string `json:"name,omitempty"`

		// PrRank The rank of the effort on the athlete's leaderboard if it belongs in the top 3 at the time of upload
		PrRank  *int `json:"pr_rank,omitempty"`
		Segment *struct {
			ActivityType    *GetSegmentEffortById200SegmentActivityType `json:"activity_type,omitempty"`
			AthletePrEffort *struct {
				// EffortCount Number of efforts by the authenticated athlete on this segment.
				EffortCount *int `json:"effort_count,omitempty"`

				// PrActivityId The unique identifier of the activity related to the PR effort.
				PrActivityId *int64 `json:"pr_activity_id,omitempty"`

				// PrDate The time at which the PR effort was started.
				PrDate *time.Time `json:"pr_date,omitempty"`

				// PrElapsedTime The elapsed time ot the PR effort.
				PrElapsedTime *int `json:"pr_elapsed_time,omitempty"`
			} `json:"athlete_pr_effort,omitempty"`
			AthleteSegmentStats *struct {
				// ActivityId The unique identifier of the activity related to this effort
				ActivityId *int64 `json:"activity_id,omitempty"`

				// Distance The effort's distance in meters
				Distance *float32 `json:"distance,omitempty"`

				// ElapsedTime The effort's elapsed time
				ElapsedTime *int `json:"elapsed_time,omitempty"`

				// Id The unique identifier of this effort
				Id *int64 `json:"id,omitempty"`

				// IsKom Whether this effort is the current best on the leaderboard
				IsKom *bool `json:"is_kom,omitempty"`

				// StartDate The time at which the effort was started.
				StartDate *time.Time `json:"start_date,omitempty"`

				// StartDateLocal The time at which the effort was started in the local timezone.
				StartDateLocal *time.Time `json:"start_date_local,omitempty"`
			} `json:"athlete_segment_stats,omitempty"`

			// AverageGrade The segment's average grade, in percents
			AverageGrade *float32 `json:"average_grade,omitempty"`

			// City The segments's city.
			City *string `json:"city,omitempty"`

			// ClimbCategory The category of the climb [0, 5]. Higher is harder ie. 5 is Hors catgorie, 0 is uncategorized in climb_category.
			ClimbCategory *int `json:"climb_category,omitempty"`

			// Country The segment's country.
			Country *string `json:"country,omitempty"`

			// Distance The segment's distance, in meters
			Distance *float32 `json:"distance,omitempty"`

			// ElevationHigh The segments's highest elevation, in meters
			ElevationHigh *float32 `json:"elevation_high,omitempty"`

			// ElevationLow The segments's lowest elevation, in meters
			ElevationLow *float32 `json:"elevation_low,omitempty"`

			// EndLatlng A pair of latitude/longitude coordinates, represented as an array of 2 floating point numbers.
			EndLatlng *[]float32 `json:"end_latlng,omitempty"`

			// Id The unique identifier of this segment
			Id *int64 `json:"id,omitempty"`

			// MaximumGrade The segments's maximum grade, in percents
			MaximumGrade *float32 `json:"maximum_grade,omitempty"`

			// Name The name of this segment
			Name *string `json:"name,omitempty"`

			// Private Whether this segment is private.
			Private *bool `json:"private,omitempty"`

			// StartLatlng A pair of latitude/longitude coordinates, represented as an array of 2 floating point numbers.
			StartLatlng *[]float32 `json:"start_latlng,omitempty"`

			// State The segments's state or geographical region.
			State *string `json:"state,omitempty"`
		} `json:"segment,omitempty"`

		// StartDate The time at which the effort was started.
		StartDate *time.Time `json:"start_date,omitempty"`

		// StartDateLocal The time at which the effort was started in the local timezone.
		StartDateLocal *time.Time `json:"start_date_local,omitempty"`

		// StartIndex The start index of this effort in its activity's stream
		StartIndex *int `json:"start_index,omitempty"`
	}
	JSONDefault *struct {
		// Errors The set of specific errors associated with this fault, if any.
		Errors *[]struct {
			// Code The code associated with this error.
			Code *string `json:"code,omitempty"`

			// Field The specific field or aspect of the resource associated with this error.
			Field *string `json:"field,omitempty"`

			// Resource The type of resource associated with this error.
			Resource *string `json:"resource,omitempty"`
		} `json:"errors,omitempty"`

		// Message The message of the fault.
		Message *string `json:"message,omitempty"`
	}
}
type GetSegmentEffortById200SegmentActivityType string

// Status returns HTTPResponse.Status
func (r GetSegmentEffortByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSegmentEffortByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExploreSegmentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Segments The set of segments matching an explorer request
		Segments *[]struct {
			// AvgGrade The segment's average grade, in percents
			AvgGrade *float32 `json:"avg_grade,omitempty"`

			// ClimbCategory The category of the climb [0, 5]. Higher is harder ie. 5 is Hors catgorie, 0 is uncategorized in climb_category. If climb_category = 5, climb_category_desc = HC. If climb_category = 2, climb_category_desc = 3.
			ClimbCategory *int `json:"climb_category,omitempty"`

			// ClimbCategoryDesc The description for the category of the climb
			ClimbCategoryDesc *ExploreSegments200SegmentsClimbCategoryDesc `json:"climb_category_desc,omitempty"`

			// Distance The segment's distance, in meters
			Distance *float32 `json:"distance,omitempty"`

			// ElevDifference The segments's evelation difference, in meters
			ElevDifference *float32 `json:"elev_difference,omitempty"`

			// EndLatlng A pair of latitude/longitude coordinates, represented as an array of 2 floating point numbers.
			EndLatlng *[]float32 `json:"end_latlng,omitempty"`

			// Id The unique identifier of this segment
			Id *int64 `json:"id,omitempty"`

			// Name The name of this segment
			Name *string `json:"name,omitempty"`

			// Points The polyline of the segment
			Points *string `json:"points,omitempty"`

			// StartLatlng A pair of latitude/longitude coordinates, represented as an array of 2 floating point numbers.
			StartLatlng *[]float32 `json:"start_latlng,omitempty"`
		} `json:"segments,omitempty"`
	}
	JSONDefault *struct {
		// Errors The set of specific errors associated with this fault, if any.
		Errors *[]struct {
			// Code The code associated with this error.
			Code *string `json:"code,omitempty"`

			// Field The specific field or aspect of the resource associated with this error.
			Field *string `json:"field,omitempty"`

			// Resource The type of resource associated with this error.
			Resource *string `json:"resource,omitempty"`
		} `json:"errors,omitempty"`

		// Message The message of the fault.
		Message *string `json:"message,omitempty"`
	}
}
type ExploreSegments200SegmentsClimbCategoryDesc string

// Status returns HTTPResponse.Status
func (r ExploreSegmentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExploreSegmentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLoggedInAthleteStarredSegmentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		ActivityType    *GetLoggedInAthleteStarredSegments200ActivityType `json:"activity_type,omitempty"`
		AthletePrEffort *struct {
			// EffortCount Number of efforts by the authenticated athlete on this segment.
			EffortCount *int `json:"effort_count,omitempty"`

			// PrActivityId The unique identifier of the activity related to the PR effort.
			PrActivityId *int64 `json:"pr_activity_id,omitempty"`

			// PrDate The time at which the PR effort was started.
			PrDate *time.Time `json:"pr_date,omitempty"`

			// PrElapsedTime The elapsed time ot the PR effort.
			PrElapsedTime *int `json:"pr_elapsed_time,omitempty"`
		} `json:"athlete_pr_effort,omitempty"`
		AthleteSegmentStats *struct {
			// ActivityId The unique identifier of the activity related to this effort
			ActivityId *int64 `json:"activity_id,omitempty"`

			// Distance The effort's distance in meters
			Distance *float32 `json:"distance,omitempty"`

			// ElapsedTime The effort's elapsed time
			ElapsedTime *int `json:"elapsed_time,omitempty"`

			// Id The unique identifier of this effort
			Id *int64 `json:"id,omitempty"`

			// IsKom Whether this effort is the current best on the leaderboard
			IsKom *bool `json:"is_kom,omitempty"`

			// StartDate The time at which the effort was started.
			StartDate *time.Time `json:"start_date,omitempty"`

			// StartDateLocal The time at which the effort was started in the local timezone.
			StartDateLocal *time.Time `json:"start_date_local,omitempty"`
		} `json:"athlete_segment_stats,omitempty"`

		// AverageGrade The segment's average grade, in percents
		AverageGrade *float32 `json:"average_grade,omitempty"`

		// City The segments's city.
		City *string `json:"city,omitempty"`

		// ClimbCategory The category of the climb [0, 5]. Higher is harder ie. 5 is Hors catgorie, 0 is uncategorized in climb_category.
		ClimbCategory *int `json:"climb_category,omitempty"`

		// Country The segment's country.
		Country *string `json:"country,omitempty"`

		// Distance The segment's distance, in meters
		Distance *float32 `json:"distance,omitempty"`

		// ElevationHigh The segments's highest elevation, in meters
		ElevationHigh *float32 `json:"elevation_high,omitempty"`

		// ElevationLow The segments's lowest elevation, in meters
		ElevationLow *float32 `json:"elevation_low,omitempty"`

		// EndLatlng A pair of latitude/longitude coordinates, represented as an array of 2 floating point numbers.
		EndLatlng *[]float32 `json:"end_latlng,omitempty"`

		// Id The unique identifier of this segment
		Id *int64 `json:"id,omitempty"`

		// MaximumGrade The segments's maximum grade, in percents
		MaximumGrade *float32 `json:"maximum_grade,omitempty"`

		// Name The name of this segment
		Name *string `json:"name,omitempty"`

		// Private Whether this segment is private.
		Private *bool `json:"private,omitempty"`

		// StartLatlng A pair of latitude/longitude coordinates, represented as an array of 2 floating point numbers.
		StartLatlng *[]float32 `json:"start_latlng,omitempty"`

		// State The segments's state or geographical region.
		State *string `json:"state,omitempty"`
	}
	JSONDefault *struct {
		// Errors The set of specific errors associated with this fault, if any.
		Errors *[]struct {
			// Code The code associated with this error.
			Code *string `json:"code,omitempty"`

			// Field The specific field or aspect of the resource associated with this error.
			Field *string `json:"field,omitempty"`

			// Resource The type of resource associated with this error.
			Resource *string `json:"resource,omitempty"`
		} `json:"errors,omitempty"`

		// Message The message of the fault.
		Message *string `json:"message,omitempty"`
	}
}
type GetLoggedInAthleteStarredSegments200ActivityType string

// Status returns HTTPResponse.Status
func (r GetLoggedInAthleteStarredSegmentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLoggedInAthleteStarredSegmentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSegmentByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		ActivityType *GetSegmentById200ActivityType `json:"activity_type,omitempty"`

		// AthleteCount The number of unique athletes who have an effort for this segment
		AthleteCount    *int `json:"athlete_count,omitempty"`
		AthletePrEffort *struct {
			// EffortCount Number of efforts by the authenticated athlete on this segment.
			EffortCount *int `json:"effort_count,omitempty"`

			// PrActivityId The unique identifier of the activity related to the PR effort.
			PrActivityId *int64 `json:"pr_activity_id,omitempty"`

			// PrDate The time at which the PR effort was started.
			PrDate *time.Time `json:"pr_date,omitempty"`

			// PrElapsedTime The elapsed time ot the PR effort.
			PrElapsedTime *int `json:"pr_elapsed_time,omitempty"`
		} `json:"athlete_pr_effort,omitempty"`
		AthleteSegmentStats *struct {
			// ActivityId The unique identifier of the activity related to this effort
			ActivityId *int64 `json:"activity_id,omitempty"`

			// Distance The effort's distance in meters
			Distance *float32 `json:"distance,omitempty"`

			// ElapsedTime The effort's elapsed time
			ElapsedTime *int `json:"elapsed_time,omitempty"`

			// Id The unique identifier of this effort
			Id *int64 `json:"id,omitempty"`

			// IsKom Whether this effort is the current best on the leaderboard
			IsKom *bool `json:"is_kom,omitempty"`

			// StartDate The time at which the effort was started.
			StartDate *time.Time `json:"start_date,omitempty"`

			// StartDateLocal The time at which the effort was started in the local timezone.
			StartDateLocal *time.Time `json:"start_date_local,omitempty"`
		} `json:"athlete_segment_stats,omitempty"`

		// AverageGrade The segment's average grade, in percents
		AverageGrade *float32 `json:"average_grade,omitempty"`

		// City The segments's city.
		City *string `json:"city,omitempty"`

		// ClimbCategory The category of the climb [0, 5]. Higher is harder ie. 5 is Hors catgorie, 0 is uncategorized in climb_category.
		ClimbCategory *int `json:"climb_category,omitempty"`

		// Country The segment's country.
		Country *string `json:"country,omitempty"`

		// CreatedAt The time at which the segment was created.
		CreatedAt *time.Time `json:"created_at,omitempty"`

		// Distance The segment's distance, in meters
		Distance *float32 `json:"distance,omitempty"`

		// EffortCount The total number of efforts for this segment
		EffortCount *int `json:"effort_count,omitempty"`

		// ElevationHigh The segments's highest elevation, in meters
		ElevationHigh *float32 `json:"elevation_high,omitempty"`

		// ElevationLow The segments's lowest elevation, in meters
		ElevationLow *float32 `json:"elevation_low,omitempty"`

		// EndLatlng A pair of latitude/longitude coordinates, represented as an array of 2 floating point numbers.
		EndLatlng *[]float32 `json:"end_latlng,omitempty"`

		// Hazardous Whether this segment is considered hazardous
		Hazardous *bool `json:"hazardous,omitempty"`

		// Id The unique identifier of this segment
		Id  *int64 `json:"id,omitempty"`
		Map *struct {
			// Id The identifier of the map
			Id *string `json:"id,omitempty"`

			// Polyline The polyline of the map, only returned on detailed representation of an object
			Polyline *string `json:"polyline,omitempty"`

			// SummaryPolyline The summary polyline of the map
			SummaryPolyline *string `json:"summary_polyline,omitempty"`
		} `json:"map,omitempty"`

		// MaximumGrade The segments's maximum grade, in percents
		MaximumGrade *float32 `json:"maximum_grade,omitempty"`

		// Name The name of this segment
		Name *string `json:"name,omitempty"`

		// Private Whether this segment is private.
		Private *bool `json:"private,omitempty"`

		// StarCount The number of stars for this segment
		StarCount *int `json:"star_count,omitempty"`

		// StartLatlng A pair of latitude/longitude coordinates, represented as an array of 2 floating point numbers.
		StartLatlng *[]float32 `json:"start_latlng,omitempty"`

		// State The segments's state or geographical region.
		State *string `json:"state,omitempty"`

		// TotalElevationGain The segment's total elevation gain.
		TotalElevationGain *float32 `json:"total_elevation_gain,omitempty"`

		// UpdatedAt The time at which the segment was last updated.
		UpdatedAt *time.Time `json:"updated_at,omitempty"`
	}
	JSONDefault *struct {
		// Errors The set of specific errors associated with this fault, if any.
		Errors *[]struct {
			// Code The code associated with this error.
			Code *string `json:"code,omitempty"`

			// Field The specific field or aspect of the resource associated with this error.
			Field *string `json:"field,omitempty"`

			// Resource The type of resource associated with this error.
			Resource *string `json:"resource,omitempty"`
		} `json:"errors,omitempty"`

		// Message The message of the fault.
		Message *string `json:"message,omitempty"`
	}
}
type GetSegmentById200ActivityType string

// Status returns HTTPResponse.Status
func (r GetSegmentByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSegmentByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetActivityByIdWithResponse request returning *GetActivityByIdResponse
func (c *ClientWithResponses) GetActivityByIdWithResponse(ctx context.Context, id int64, params *GetActivityByIdParams, reqEditors ...RequestEditorFn) (*GetActivityByIdResponse, error) {
	rsp, err := c.GetActivityById(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetActivityByIdResponse(rsp)
}

// GetCommentsByActivityIdWithResponse request returning *GetCommentsByActivityIdResponse
func (c *ClientWithResponses) GetCommentsByActivityIdWithResponse(ctx context.Context, id int64, params *GetCommentsByActivityIdParams, reqEditors ...RequestEditorFn) (*GetCommentsByActivityIdResponse, error) {
	rsp, err := c.GetCommentsByActivityId(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCommentsByActivityIdResponse(rsp)
}

// GetKudoersByActivityIdWithResponse request returning *GetKudoersByActivityIdResponse
func (c *ClientWithResponses) GetKudoersByActivityIdWithResponse(ctx context.Context, id int64, params *GetKudoersByActivityIdParams, reqEditors ...RequestEditorFn) (*GetKudoersByActivityIdResponse, error) {
	rsp, err := c.GetKudoersByActivityId(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetKudoersByActivityIdResponse(rsp)
}

// GetLapsByActivityIdWithResponse request returning *GetLapsByActivityIdResponse
func (c *ClientWithResponses) GetLapsByActivityIdWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*GetLapsByActivityIdResponse, error) {
	rsp, err := c.GetLapsByActivityId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLapsByActivityIdResponse(rsp)
}

// GetActivityStreamsWithResponse request returning *GetActivityStreamsResponse
func (c *ClientWithResponses) GetActivityStreamsWithResponse(ctx context.Context, id int64, params *GetActivityStreamsParams, reqEditors ...RequestEditorFn) (*GetActivityStreamsResponse, error) {
	rsp, err := c.GetActivityStreams(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetActivityStreamsResponse(rsp)
}

// GetZonesByActivityIdWithResponse request returning *GetZonesByActivityIdResponse
func (c *ClientWithResponses) GetZonesByActivityIdWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*GetZonesByActivityIdResponse, error) {
	rsp, err := c.GetZonesByActivityId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetZonesByActivityIdResponse(rsp)
}

// GetLoggedInAthleteWithResponse request returning *GetLoggedInAthleteResponse
func (c *ClientWithResponses) GetLoggedInAthleteWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLoggedInAthleteResponse, error) {
	rsp, err := c.GetLoggedInAthlete(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLoggedInAthleteResponse(rsp)
}

// GetLoggedInAthleteActivitiesWithResponse request returning *GetLoggedInAthleteActivitiesResponse
func (c *ClientWithResponses) GetLoggedInAthleteActivitiesWithResponse(ctx context.Context, params *GetLoggedInAthleteActivitiesParams, reqEditors ...RequestEditorFn) (*GetLoggedInAthleteActivitiesResponse, error) {
	rsp, err := c.GetLoggedInAthleteActivities(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLoggedInAthleteActivitiesResponse(rsp)
}

// GetLoggedInAthleteClubsWithResponse request returning *GetLoggedInAthleteClubsResponse
func (c *ClientWithResponses) GetLoggedInAthleteClubsWithResponse(ctx context.Context, params *GetLoggedInAthleteClubsParams, reqEditors ...RequestEditorFn) (*GetLoggedInAthleteClubsResponse, error) {
	rsp, err := c.GetLoggedInAthleteClubs(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLoggedInAthleteClubsResponse(rsp)
}

// GetLoggedInAthleteZonesWithResponse request returning *GetLoggedInAthleteZonesResponse
func (c *ClientWithResponses) GetLoggedInAthleteZonesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetLoggedInAthleteZonesResponse, error) {
	rsp, err := c.GetLoggedInAthleteZones(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLoggedInAthleteZonesResponse(rsp)
}

// GetRoutesByAthleteIdWithResponse request returning *GetRoutesByAthleteIdResponse
func (c *ClientWithResponses) GetRoutesByAthleteIdWithResponse(ctx context.Context, id int64, params *GetRoutesByAthleteIdParams, reqEditors ...RequestEditorFn) (*GetRoutesByAthleteIdResponse, error) {
	rsp, err := c.GetRoutesByAthleteId(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRoutesByAthleteIdResponse(rsp)
}

// GetStatsWithResponse request returning *GetStatsResponse
func (c *ClientWithResponses) GetStatsWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*GetStatsResponse, error) {
	rsp, err := c.GetStats(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStatsResponse(rsp)
}

// GetClubByIdWithResponse request returning *GetClubByIdResponse
func (c *ClientWithResponses) GetClubByIdWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*GetClubByIdResponse, error) {
	rsp, err := c.GetClubById(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClubByIdResponse(rsp)
}

// GetClubActivitiesByIdWithResponse request returning *GetClubActivitiesByIdResponse
func (c *ClientWithResponses) GetClubActivitiesByIdWithResponse(ctx context.Context, id int64, params *GetClubActivitiesByIdParams, reqEditors ...RequestEditorFn) (*GetClubActivitiesByIdResponse, error) {
	rsp, err := c.GetClubActivitiesById(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClubActivitiesByIdResponse(rsp)
}

// GetClubMembersByIdWithResponse request returning *GetClubMembersByIdResponse
func (c *ClientWithResponses) GetClubMembersByIdWithResponse(ctx context.Context, id int64, params *GetClubMembersByIdParams, reqEditors ...RequestEditorFn) (*GetClubMembersByIdResponse, error) {
	rsp, err := c.GetClubMembersById(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClubMembersByIdResponse(rsp)
}

// GetGearByIdWithResponse request returning *GetGearByIdResponse
func (c *ClientWithResponses) GetGearByIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetGearByIdResponse, error) {
	rsp, err := c.GetGearById(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGearByIdResponse(rsp)
}

// GetRouteByIdWithResponse request returning *GetRouteByIdResponse
func (c *ClientWithResponses) GetRouteByIdWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*GetRouteByIdResponse, error) {
	rsp, err := c.GetRouteById(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRouteByIdResponse(rsp)
}

// GetEffortsBySegmentIdWithResponse request returning *GetEffortsBySegmentIdResponse
func (c *ClientWithResponses) GetEffortsBySegmentIdWithResponse(ctx context.Context, params *GetEffortsBySegmentIdParams, reqEditors ...RequestEditorFn) (*GetEffortsBySegmentIdResponse, error) {
	rsp, err := c.GetEffortsBySegmentId(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEffortsBySegmentIdResponse(rsp)
}

// GetSegmentEffortByIdWithResponse request returning *GetSegmentEffortByIdResponse
func (c *ClientWithResponses) GetSegmentEffortByIdWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*GetSegmentEffortByIdResponse, error) {
	rsp, err := c.GetSegmentEffortById(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSegmentEffortByIdResponse(rsp)
}

// ExploreSegmentsWithResponse request returning *ExploreSegmentsResponse
func (c *ClientWithResponses) ExploreSegmentsWithResponse(ctx context.Context, params *ExploreSegmentsParams, reqEditors ...RequestEditorFn) (*ExploreSegmentsResponse, error) {
	rsp, err := c.ExploreSegments(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExploreSegmentsResponse(rsp)
}

// GetLoggedInAthleteStarredSegmentsWithResponse request returning *GetLoggedInAthleteStarredSegmentsResponse
func (c *ClientWithResponses) GetLoggedInAthleteStarredSegmentsWithResponse(ctx context.Context, params *GetLoggedInAthleteStarredSegmentsParams, reqEditors ...RequestEditorFn) (*GetLoggedInAthleteStarredSegmentsResponse, error) {
	rsp, err := c.GetLoggedInAthleteStarredSegments(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLoggedInAthleteStarredSegmentsResponse(rsp)
}

// GetSegmentByIdWithResponse request returning *GetSegmentByIdResponse
func (c *ClientWithResponses) GetSegmentByIdWithResponse(ctx context.Context, id int64, reqEditors ...RequestEditorFn) (*GetSegmentByIdResponse, error) {
	rsp, err := c.GetSegmentById(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSegmentByIdResponse(rsp)
}

// ParseGetActivityByIdResponse parses an HTTP response from a GetActivityByIdWithResponse call
func ParseGetActivityByIdResponse(rsp *http.Response) (*GetActivityByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetActivityByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AchievementCount The number of achievements gained during this activity
			AchievementCount *int `json:"achievement_count,omitempty"`
			Athlete          *struct {
				// Id The unique identifier of the athlete
				Id *int64 `json:"id,omitempty"`
			} `json:"athlete,omitempty"`

			// AthleteCount The number of athletes for taking part in a group activity
			AthleteCount *int `json:"athlete_count,omitempty"`

			// AverageSpeed The activity's average speed, in meters per second
			AverageSpeed *float32 `json:"average_speed,omitempty"`

			// AverageWatts Average power output in watts during this activity. Rides only
			AverageWatts *float32 `json:"average_watts,omitempty"`
			BestEfforts  *[]struct {
				Activity *struct {
					// Id The unique identifier of the activity
					Id *int64 `json:"id,omitempty"`
				} `json:"activity,omitempty"`

				// ActivityId The unique identifier of the activity related to this effort
				ActivityId *int64 `json:"activity_id,omitempty"`
				Athlete    *struct {
					// Id The unique identifier of the athlete
					Id *int64 `json:"id,omitempty"`
				} `json:"athlete,omitempty"`

				// AverageCadence The effort's average cadence
				AverageCadence *float32 `json:"average_cadence,omitempty"`

				// AverageHeartrate The heart heart rate of the athlete during this effort
				AverageHeartrate *float32 `json:"average_heartrate,omitempty"`

				// AverageWatts The average wattage of this effort
				AverageWatts *float32 `json:"average_watts,omitempty"`

				// DeviceWatts For riding efforts, whether the wattage was reported by a dedicated recording device
				DeviceWatts *bool `json:"device_watts,omitempty"`

				// Distance The effort's distance in meters
				Distance *float32 `json:"distance,omitempty"`

				// ElapsedTime The effort's elapsed time
				ElapsedTime *int `json:"elapsed_time,omitempty"`

				// EndIndex The end index of this effort in its activity's stream
				EndIndex *int `json:"end_index,omitempty"`

				// Hidden Whether this effort should be hidden when viewed within an activity
				Hidden *bool `json:"hidden,omitempty"`

				// Id The unique identifier of this effort
				Id *int64 `json:"id,omitempty"`

				// IsKom Whether this effort is the current best on the leaderboard
				IsKom *bool `json:"is_kom,omitempty"`

				// KomRank The rank of the effort on the global leaderboard if it belongs in the top 10 at the time of upload
				KomRank *int `json:"kom_rank,omitempty"`

				// MaxHeartrate The maximum heart rate of the athlete during this effort
				MaxHeartrate *float32 `json:"max_heartrate,omitempty"`

				// MovingTime The effort's moving time
				MovingTime *int `json:"moving_time,omitempty"`

				// Name The name of the segment on which this effort was performed
				Name *string `json:"name,omitempty"`

				// PrRank The rank of the effort on the athlete's leaderboard if it belongs in the top 3 at the time of upload
				PrRank  *int `json:"pr_rank,omitempty"`
				Segment *struct {
					ActivityType    *GetActivityById200BestEffortsSegmentActivityType `json:"activity_type,omitempty"`
					AthletePrEffort *struct {
						// EffortCount Number of efforts by the authenticated athlete on this segment.
						EffortCount *int `json:"effort_count,omitempty"`

						// PrActivityId The unique identifier of the activity related to the PR effort.
						PrActivityId *int64 `json:"pr_activity_id,omitempty"`

						// PrDate The time at which the PR effort was started.
						PrDate *time.Time `json:"pr_date,omitempty"`

						// PrElapsedTime The elapsed time ot the PR effort.
						PrElapsedTime *int `json:"pr_elapsed_time,omitempty"`
					} `json:"athlete_pr_effort,omitempty"`
					AthleteSegmentStats *struct {
						// ActivityId The unique identifier of the activity related to this effort
						ActivityId *int64 `json:"activity_id,omitempty"`

						// Distance The effort's distance in meters
						Distance *float32 `json:"distance,omitempty"`

						// ElapsedTime The effort's elapsed time
						ElapsedTime *int `json:"elapsed_time,omitempty"`

						// Id The unique identifier of this effort
						Id *int64 `json:"id,omitempty"`

						// IsKom Whether this effort is the current best on the leaderboard
						IsKom *bool `json:"is_kom,omitempty"`

						// StartDate The time at which the effort was started.
						StartDate *time.Time `json:"start_date,omitempty"`

						// StartDateLocal The time at which the effort was started in the local timezone.
						StartDateLocal *time.Time `json:"start_date_local,omitempty"`
					} `json:"athlete_segment_stats,omitempty"`

					// AverageGrade The segment's average grade, in percents
					AverageGrade *float32 `json:"average_grade,omitempty"`

					// City The segments's city.
					City *string `json:"city,omitempty"`

					// ClimbCategory The category of the climb [0, 5]. Higher is harder ie. 5 is Hors catgorie, 0 is uncategorized in climb_category.
					ClimbCategory *int `json:"climb_category,omitempty"`

					// Country The segment's country.
					Country *string `json:"country,omitempty"`

					// Distance The segment's distance, in meters
					Distance *float32 `json:"distance,omitempty"`

					// ElevationHigh The segments's highest elevation, in meters
					ElevationHigh *float32 `json:"elevation_high,omitempty"`

					// ElevationLow The segments's lowest elevation, in meters
					ElevationLow *float32 `json:"elevation_low,omitempty"`

					// EndLatlng A pair of latitude/longitude coordinates, represented as an array of 2 floating point numbers.
					EndLatlng *[]float32 `json:"end_latlng,omitempty"`

					// Id The unique identifier of this segment
					Id *int64 `json:"id,omitempty"`

					// MaximumGrade The segments's maximum grade, in percents
					MaximumGrade *float32 `json:"maximum_grade,omitempty"`

					// Name The name of this segment
					Name *string `json:"name,omitempty"`

					// Private Whether this segment is private.
					Private *bool `json:"private,omitempty"`

					// StartLatlng A pair of latitude/longitude coordinates, represented as an array of 2 floating point numbers.
					StartLatlng *[]float32 `json:"start_latlng,omitempty"`

					// State The segments's state or geographical region.
					State *string `json:"state,omitempty"`
				} `json:"segment,omitempty"`

				// StartDate The time at which the effort was started.
				StartDate *time.Time `json:"start_date,omitempty"`

				// StartDateLocal The time at which the effort was started in the local timezone.
				StartDateLocal *time.Time `json:"start_date_local,omitempty"`

				// StartIndex The start index of this effort in its activity's stream
				StartIndex *int `json:"start_index,omitempty"`
			} `json:"best_efforts,omitempty"`

			// Calories The number of kilocalories consumed during this activity
			Calories *float32 `json:"calories,omitempty"`

			// CommentCount The number of comments for this activity
			CommentCount *int `json:"comment_count,omitempty"`

			// Commute Whether this activity is a commute
			Commute *bool `json:"commute,omitempty"`

			// Description The description of the activity
			Description *string `json:"description,omitempty"`

			// DeviceName The name of the device used to record the activity
			DeviceName *string `json:"device_name,omitempty"`

			// DeviceWatts Whether the watts are from a power meter, false if estimated
			DeviceWatts *bool `json:"device_watts,omitempty"`

			// Distance The activity's distance, in meters
			Distance *float32 `json:"distance,omitempty"`

			// ElapsedTime The activity's elapsed time, in seconds
			ElapsedTime *int `json:"elapsed_time,omitempty"`

			// ElevHigh The activity's highest elevation, in meters
			ElevHigh *float32 `json:"elev_high,omitempty"`

			// ElevLow The activity's lowest elevation, in meters
			ElevLow *float32 `json:"elev_low,omitempty"`

			// EmbedToken The token used to embed a Strava activity
			EmbedToken *string `json:"embed_token,omitempty"`

			// EndLatlng A pair of latitude/longitude coordinates, represented as an array of 2 floating point numbers.
			EndLatlng *[]float32 `json:"end_latlng,omitempty"`

			// ExternalId The identifier provided at upload time
			ExternalId *string `json:"external_id,omitempty"`

			// Flagged Whether this activity is flagged
			Flagged *bool `json:"flagged,omitempty"`
			Gear    *struct {
				// Distance The distance logged with this gear.
				Distance *float32 `json:"distance,omitempty"`

				// Id The gear's unique identifier.
				Id *string `json:"id,omitempty"`

				// Name The gear's name.
				Name *string `json:"name,omitempty"`

				// Primary Whether this gear's is the owner's default one.
				Primary *bool `json:"primary,omitempty"`

				// ResourceState Resource state, indicates level of detail. Possible values: 2 -> "summary", 3 -> "detail"
				ResourceState *int `json:"resource_state,omitempty"`
			} `json:"gear,omitempty"`

			// GearId The id of the gear for the activity
			GearId *string `json:"gear_id,omitempty"`

			// HasKudoed Whether the logged-in athlete has kudoed this activity
			HasKudoed *bool `json:"has_kudoed,omitempty"`

			// HideFromHome Whether the activity is muted
			HideFromHome *bool `json:"hide_from_home,omitempty"`

			// Id The unique identifier of the activity
			Id *int64 `json:"id,omitempty"`

			// Kilojoules The total work done in kilojoules during this activity. Rides only
			Kilojoules *float32 `json:"kilojoules,omitempty"`

			// KudosCount The number of kudos given for this activity
			KudosCount *int `json:"kudos_count,omitempty"`
			Laps       *[]struct {
				Activity *struct {
					// Id The unique identifier of the activity
					Id *int64 `json:"id,omitempty"`
				} `json:"activity,omitempty"`
				Athlete *struct {
					// Id The unique identifier of the athlete
					Id *int64 `json:"id,omitempty"`
				} `json:"athlete,omitempty"`

				// AverageCadence The lap's average cadence
				AverageCadence *float32 `json:"average_cadence,omitempty"`

				// AverageSpeed The lap's average speed
				AverageSpeed *float32 `json:"average_speed,omitempty"`

				// Distance The lap's distance, in meters
				Distance *float32 `json:"distance,omitempty"`

				// ElapsedTime The lap's elapsed time, in seconds
				ElapsedTime *int `json:"elapsed_time,omitempty"`

				// EndIndex The end index of this effort in its activity's stream
				EndIndex *int `json:"end_index,omitempty"`

				// Id The unique identifier of this lap
				Id *int64 `json:"id,omitempty"`

				// LapIndex The index of this lap in the activity it belongs to
				LapIndex *int `json:"lap_index,omitempty"`

				// MaxSpeed The maximum speed of this lat, in meters per second
				MaxSpeed *float32 `json:"max_speed,omitempty"`

				// MovingTime The lap's moving time, in seconds
				MovingTime *int `json:"moving_time,omitempty"`

				// Name The name of the lap
				Name *string `json:"name,omitempty"`

				// PaceZone The athlete's pace zone during this lap
				PaceZone *int `json:"pace_zone,omitempty"`
				Split    *int `json:"split,omitempty"`

				// StartDate The time at which the lap was started.
				StartDate *time.Time `json:"start_date,omitempty"`

				// StartDateLocal The time at which the lap was started in the local timezone.
				StartDateLocal *time.Time `json:"start_date_local,omitempty"`

				// StartIndex The start index of this effort in its activity's stream
				StartIndex *int `json:"start_index,omitempty"`

				// TotalElevationGain The elevation gain of this lap, in meters
				TotalElevationGain *float32 `json:"total_elevation_gain,omitempty"`
			} `json:"laps,omitempty"`

			// Manual Whether this activity was created manually
			Manual *bool `json:"manual,omitempty"`
			Map    *struct {
				// Id The identifier of the map
				Id *string `json:"id,omitempty"`

				// Polyline The polyline of the map, only returned on detailed representation of an object
				Polyline *string `json:"polyline,omitempty"`

				// SummaryPolyline The summary polyline of the map
				SummaryPolyline *string `json:"summary_polyline,omitempty"`
			} `json:"map,omitempty"`

			// MaxSpeed The activity's max speed, in meters per second
			MaxSpeed *float32 `json:"max_speed,omitempty"`

			// MaxWatts Rides with power meter data only
			MaxWatts *int `json:"max_watts,omitempty"`

			// MovingTime The activity's moving time, in seconds
			MovingTime *int `json:"moving_time,omitempty"`

			// Name The name of the activity
			Name *string `json:"name,omitempty"`

			// PhotoCount The number of Instagram photos for this activity
			PhotoCount *int `json:"photo_count,omitempty"`
			Photos     *struct {
				// Count The number of photos
				Count   *int `json:"count,omitempty"`
				Primary *struct {
					Id       *int64             `json:"id,omitempty"`
					Source   *int               `json:"source,omitempty"`
					UniqueId *string            `json:"unique_id,omitempty"`
					Urls     *map[string]string `json:"urls,omitempty"`
				} `json:"primary,omitempty"`
			} `json:"photos,omitempty"`

			// Private Whether this activity is private
			Private        *bool `json:"private,omitempty"`
			SegmentEfforts *[]struct {
				Activity *struct {
					// Id The unique identifier of the activity
					Id *int64 `json:"id,omitempty"`
				} `json:"activity,omitempty"`

				// ActivityId The unique identifier of the activity related to this effort
				ActivityId *int64 `json:"activity_id,omitempty"`
				Athlete    *struct {
					// Id The unique identifier of the athlete
					Id *int64 `json:"id,omitempty"`
				} `json:"athlete,omitempty"`

				// AverageCadence The effort's average cadence
				AverageCadence *float32 `json:"average_cadence,omitempty"`

				// AverageHeartrate The heart heart rate of the athlete during this effort
				AverageHeartrate *float32 `json:"average_heartrate,omitempty"`

				// AverageWatts The average wattage of this effort
				AverageWatts *float32 `json:"average_watts,omitempty"`

				// DeviceWatts For riding efforts, whether the wattage was reported by a dedicated recording device
				DeviceWatts *bool `json:"device_watts,omitempty"`

				// Distance The effort's distance in meters
				Distance *float32 `json:"distance,omitempty"`

				// ElapsedTime The effort's elapsed time
				ElapsedTime *int `json:"elapsed_time,omitempty"`

				// EndIndex The end index of this effort in its activity's stream
				EndIndex *int `json:"end_index,omitempty"`

				// Hidden Whether this effort should be hidden when viewed within an activity
				Hidden *bool `json:"hidden,omitempty"`

				// Id The unique identifier of this effort
				Id *int64 `json:"id,omitempty"`

				// IsKom Whether this effort is the current best on the leaderboard
				IsKom *bool `json:"is_kom,omitempty"`

				// KomRank The rank of the effort on the global leaderboard if it belongs in the top 10 at the time of upload
				KomRank *int `json:"kom_rank,omitempty"`

				// MaxHeartrate The maximum heart rate of the athlete during this effort
				MaxHeartrate *float32 `json:"max_heartrate,omitempty"`

				// MovingTime The effort's moving time
				MovingTime *int `json:"moving_time,omitempty"`

				// Name The name of the segment on which this effort was performed
				Name *string `json:"name,omitempty"`

				// PrRank The rank of the effort on the athlete's leaderboard if it belongs in the top 3 at the time of upload
				PrRank  *int `json:"pr_rank,omitempty"`
				Segment *struct {
					ActivityType    *GetActivityById200SegmentEffortsSegmentActivityType `json:"activity_type,omitempty"`
					AthletePrEffort *struct {
						// EffortCount Number of efforts by the authenticated athlete on this segment.
						EffortCount *int `json:"effort_count,omitempty"`

						// PrActivityId The unique identifier of the activity related to the PR effort.
						PrActivityId *int64 `json:"pr_activity_id,omitempty"`

						// PrDate The time at which the PR effort was started.
						PrDate *time.Time `json:"pr_date,omitempty"`

						// PrElapsedTime The elapsed time ot the PR effort.
						PrElapsedTime *int `json:"pr_elapsed_time,omitempty"`
					} `json:"athlete_pr_effort,omitempty"`
					AthleteSegmentStats *struct {
						// ActivityId The unique identifier of the activity related to this effort
						ActivityId *int64 `json:"activity_id,omitempty"`

						// Distance The effort's distance in meters
						Distance *float32 `json:"distance,omitempty"`

						// ElapsedTime The effort's elapsed time
						ElapsedTime *int `json:"elapsed_time,omitempty"`

						// Id The unique identifier of this effort
						Id *int64 `json:"id,omitempty"`

						// IsKom Whether this effort is the current best on the leaderboard
						IsKom *bool `json:"is_kom,omitempty"`

						// StartDate The time at which the effort was started.
						StartDate *time.Time `json:"start_date,omitempty"`

						// StartDateLocal The time at which the effort was started in the local timezone.
						StartDateLocal *time.Time `json:"start_date_local,omitempty"`
					} `json:"athlete_segment_stats,omitempty"`

					// AverageGrade The segment's average grade, in percents
					AverageGrade *float32 `json:"average_grade,omitempty"`

					// City The segments's city.
					City *string `json:"city,omitempty"`

					// ClimbCategory The category of the climb [0, 5]. Higher is harder ie. 5 is Hors catgorie, 0 is uncategorized in climb_category.
					ClimbCategory *int `json:"climb_category,omitempty"`

					// Country The segment's country.
					Country *string `json:"country,omitempty"`

					// Distance The segment's distance, in meters
					Distance *float32 `json:"distance,omitempty"`

					// ElevationHigh The segments's highest elevation, in meters
					ElevationHigh *float32 `json:"elevation_high,omitempty"`

					// ElevationLow The segments's lowest elevation, in meters
					ElevationLow *float32 `json:"elevation_low,omitempty"`

					// EndLatlng A pair of latitude/longitude coordinates, represented as an array of 2 floating point numbers.
					EndLatlng *[]float32 `json:"end_latlng,omitempty"`

					// Id The unique identifier of this segment
					Id *int64 `json:"id,omitempty"`

					// MaximumGrade The segments's maximum grade, in percents
					MaximumGrade *float32 `json:"maximum_grade,omitempty"`

					// Name The name of this segment
					Name *string `json:"name,omitempty"`

					// Private Whether this segment is private.
					Private *bool `json:"private,omitempty"`

					// StartLatlng A pair of latitude/longitude coordinates, represented as an array of 2 floating point numbers.
					StartLatlng *[]float32 `json:"start_latlng,omitempty"`

					// State The segments's state or geographical region.
					State *string `json:"state,omitempty"`
				} `json:"segment,omitempty"`

				// StartDate The time at which the effort was started.
				StartDate *time.Time `json:"start_date,omitempty"`

				// StartDateLocal The time at which the effort was started in the local timezone.
				StartDateLocal *time.Time `json:"start_date_local,omitempty"`

				// StartIndex The start index of this effort in its activity's stream
				StartIndex *int `json:"start_index,omitempty"`
			} `json:"segment_efforts,omitempty"`

			// SplitsMetric The splits of this activity in metric units (for runs)
			SplitsMetric *[]struct {
				// AverageSpeed The average speed of this split, in meters per second
				AverageSpeed *float32 `json:"average_speed,omitempty"`

				// Distance The distance of this split, in meters
				Distance *float32 `json:"distance,omitempty"`

				// ElapsedTime The elapsed time of this split, in seconds
				ElapsedTime *int `json:"elapsed_time,omitempty"`

				// ElevationDifference The elevation difference of this split, in meters
				ElevationDifference *float32 `json:"elevation_difference,omitempty"`

				// MovingTime The moving time of this split, in seconds
				MovingTime *int `json:"moving_time,omitempty"`

				// PaceZone The pacing zone of this split
				PaceZone *int `json:"pace_zone,omitempty"`

				// Split N/A
				Split *int `json:"split,omitempty"`
			} `json:"splits_metric,omitempty"`

			// SplitsStandard The splits of this activity in imperial units (for runs)
			SplitsStandard *[]struct {
				// AverageSpeed The average speed of this split, in meters per second
				AverageSpeed *float32 `json:"average_speed,omitempty"`

				// Distance The distance of this split, in meters
				Distance *float32 `json:"distance,omitempty"`

				// ElapsedTime The elapsed time of this split, in seconds
				ElapsedTime *int `json:"elapsed_time,omitempty"`

				// ElevationDifference The elevation difference of this split, in meters
				ElevationDifference *float32 `json:"elevation_difference,omitempty"`

				// MovingTime The moving time of this split, in seconds
				MovingTime *int `json:"moving_time,omitempty"`

				// PaceZone The pacing zone of this split
				PaceZone *int `json:"pace_zone,omitempty"`

				// Split N/A
				Split *int `json:"split,omitempty"`
			} `json:"splits_standard,omitempty"`

			// SportType An enumeration of the sport types an activity may have. Distinct from ActivityType in that it has new types (e.g. MountainBikeRide)
			SportType *GetActivityById200SportType `json:"sport_type,omitempty"`

			// StartDate The time at which the activity was started.
			StartDate *time.Time `json:"start_date,omitempty"`

			// StartDateLocal The time at which the activity was started in the local timezone.
			StartDateLocal *time.Time `json:"start_date_local,omitempty"`

			// StartLatlng A pair of latitude/longitude coordinates, represented as an array of 2 floating point numbers.
			StartLatlng *[]float32 `json:"start_latlng,omitempty"`

			// Timezone The timezone of the activity
			Timezone *string `json:"timezone,omitempty"`

			// TotalElevationGain The activity's total elevation gain.
			TotalElevationGain *float32 `json:"total_elevation_gain,omitempty"`

			// TotalPhotoCount The number of Instagram and Strava photos for this activity
			TotalPhotoCount *int `json:"total_photo_count,omitempty"`

			// Trainer Whether this activity was recorded on a training machine
			Trainer *bool `json:"trainer,omitempty"`

			// Type Deprecated. Prefer to use sport_type
			Type *GetActivityById200Type `json:"type,omitempty"`

			// UploadId The identifier of the upload that resulted in this activity
			UploadId *int64 `json:"upload_id,omitempty"`

			// UploadIdStr The unique identifier of the upload in string format
			UploadIdStr *string `json:"upload_id_str,omitempty"`

			// WeightedAverageWatts Similar to Normalized Power. Rides with power meter data only
			WeightedAverageWatts *int `json:"weighted_average_watts,omitempty"`

			// WorkoutType The activity's workout type
			WorkoutType *int `json:"workout_type,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			// Errors The set of specific errors associated with this fault, if any.
			Errors *[]struct {
				// Code The code associated with this error.
				Code *string `json:"code,omitempty"`

				// Field The specific field or aspect of the resource associated with this error.
				Field *string `json:"field,omitempty"`

				// Resource The type of resource associated with this error.
				Resource *string `json:"resource,omitempty"`
			} `json:"errors,omitempty"`

			// Message The message of the fault.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetCommentsByActivityIdResponse parses an HTTP response from a GetCommentsByActivityIdWithResponse call
func ParseGetCommentsByActivityIdResponse(rsp *http.Response) (*GetCommentsByActivityIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCommentsByActivityIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			// ActivityId The identifier of the activity this comment is related to
			ActivityId *int64 `json:"activity_id,omitempty"`
			Athlete    *struct {
				// City The athlete's city.
				City *string `json:"city,omitempty"`

				// Country The athlete's country.
				Country *string `json:"country,omitempty"`

				// CreatedAt The time at which the athlete was created.
				CreatedAt *time.Time `json:"created_at,omitempty"`

				// Firstname The athlete's first name.
				Firstname *string `json:"firstname,omitempty"`

				// Id The unique identifier of the athlete
				Id *int64 `json:"id,omitempty"`

				// Lastname The athlete's last name.
				Lastname *string `json:"lastname,omitempty"`

				// Premium Deprecated.  Use summit field instead. Whether the athlete has any Summit subscription.
				Premium *bool `json:"premium,omitempty"`

				// Profile URL to a 124x124 pixel profile picture.
				Profile *string `json:"profile,omitempty"`

				// ProfileMedium URL to a 62x62 pixel profile picture.
				ProfileMedium *string `json:"profile_medium,omitempty"`

				// ResourceState Resource state, indicates level of detail. Possible values: 1 -> "meta", 2 -> "summary", 3 -> "detail"
				ResourceState *int `json:"resource_state,omitempty"`

				// Sex The athlete's sex.
				Sex *GetCommentsByActivityId200AthleteSex `json:"sex,omitempty"`

				// State The athlete's state or geographical region.
				State *string `json:"state,omitempty"`

				// Summit Whether the athlete has any Summit subscription.
				Summit *bool `json:"summit,omitempty"`

				// UpdatedAt The time at which the athlete was last updated.
				UpdatedAt *time.Time `json:"updated_at,omitempty"`
			} `json:"athlete,omitempty"`

			// CreatedAt The time at which this comment was created.
			CreatedAt *time.Time `json:"created_at,omitempty"`

			// Id The unique identifier of this comment
			Id *int64 `json:"id,omitempty"`

			// Text The content of the comment
			Text *string `json:"text,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			// Errors The set of specific errors associated with this fault, if any.
			Errors *[]struct {
				// Code The code associated with this error.
				Code *string `json:"code,omitempty"`

				// Field The specific field or aspect of the resource associated with this error.
				Field *string `json:"field,omitempty"`

				// Resource The type of resource associated with this error.
				Resource *string `json:"resource,omitempty"`
			} `json:"errors,omitempty"`

			// Message The message of the fault.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetKudoersByActivityIdResponse parses an HTTP response from a GetKudoersByActivityIdWithResponse call
func ParseGetKudoersByActivityIdResponse(rsp *http.Response) (*GetKudoersByActivityIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetKudoersByActivityIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			// City The athlete's city.
			City *string `json:"city,omitempty"`

			// Country The athlete's country.
			Country *string `json:"country,omitempty"`

			// CreatedAt The time at which the athlete was created.
			CreatedAt *time.Time `json:"created_at,omitempty"`

			// Firstname The athlete's first name.
			Firstname *string `json:"firstname,omitempty"`

			// Id The unique identifier of the athlete
			Id *int64 `json:"id,omitempty"`

			// Lastname The athlete's last name.
			Lastname *string `json:"lastname,omitempty"`

			// Premium Deprecated.  Use summit field instead. Whether the athlete has any Summit subscription.
			Premium *bool `json:"premium,omitempty"`

			// Profile URL to a 124x124 pixel profile picture.
			Profile *string `json:"profile,omitempty"`

			// ProfileMedium URL to a 62x62 pixel profile picture.
			ProfileMedium *string `json:"profile_medium,omitempty"`

			// ResourceState Resource state, indicates level of detail. Possible values: 1 -> "meta", 2 -> "summary", 3 -> "detail"
			ResourceState *int `json:"resource_state,omitempty"`

			// Sex The athlete's sex.
			Sex *GetKudoersByActivityId200Sex `json:"sex,omitempty"`

			// State The athlete's state or geographical region.
			State *string `json:"state,omitempty"`

			// Summit Whether the athlete has any Summit subscription.
			Summit *bool `json:"summit,omitempty"`

			// UpdatedAt The time at which the athlete was last updated.
			UpdatedAt *time.Time `json:"updated_at,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			// Errors The set of specific errors associated with this fault, if any.
			Errors *[]struct {
				// Code The code associated with this error.
				Code *string `json:"code,omitempty"`

				// Field The specific field or aspect of the resource associated with this error.
				Field *string `json:"field,omitempty"`

				// Resource The type of resource associated with this error.
				Resource *string `json:"resource,omitempty"`
			} `json:"errors,omitempty"`

			// Message The message of the fault.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetLapsByActivityIdResponse parses an HTTP response from a GetLapsByActivityIdWithResponse call
func ParseGetLapsByActivityIdResponse(rsp *http.Response) (*GetLapsByActivityIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLapsByActivityIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			Activity *struct {
				// Id The unique identifier of the activity
				Id *int64 `json:"id,omitempty"`
			} `json:"activity,omitempty"`
			Athlete *struct {
				// Id The unique identifier of the athlete
				Id *int64 `json:"id,omitempty"`
			} `json:"athlete,omitempty"`

			// AverageCadence The lap's average cadence
			AverageCadence *float32 `json:"average_cadence,omitempty"`

			// AverageSpeed The lap's average speed
			AverageSpeed *float32 `json:"average_speed,omitempty"`

			// Distance The lap's distance, in meters
			Distance *float32 `json:"distance,omitempty"`

			// ElapsedTime The lap's elapsed time, in seconds
			ElapsedTime *int `json:"elapsed_time,omitempty"`

			// EndIndex The end index of this effort in its activity's stream
			EndIndex *int `json:"end_index,omitempty"`

			// Id The unique identifier of this lap
			Id *int64 `json:"id,omitempty"`

			// LapIndex The index of this lap in the activity it belongs to
			LapIndex *int `json:"lap_index,omitempty"`

			// MaxSpeed The maximum speed of this lat, in meters per second
			MaxSpeed *float32 `json:"max_speed,omitempty"`

			// MovingTime The lap's moving time, in seconds
			MovingTime *int `json:"moving_time,omitempty"`

			// Name The name of the lap
			Name *string `json:"name,omitempty"`

			// PaceZone The athlete's pace zone during this lap
			PaceZone *int `json:"pace_zone,omitempty"`
			Split    *int `json:"split,omitempty"`

			// StartDate The time at which the lap was started.
			StartDate *time.Time `json:"start_date,omitempty"`

			// StartDateLocal The time at which the lap was started in the local timezone.
			StartDateLocal *time.Time `json:"start_date_local,omitempty"`

			// StartIndex The start index of this effort in its activity's stream
			StartIndex *int `json:"start_index,omitempty"`

			// TotalElevationGain The elevation gain of this lap, in meters
			TotalElevationGain *float32 `json:"total_elevation_gain,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			// Errors The set of specific errors associated with this fault, if any.
			Errors *[]struct {
				// Code The code associated with this error.
				Code *string `json:"code,omitempty"`

				// Field The specific field or aspect of the resource associated with this error.
				Field *string `json:"field,omitempty"`

				// Resource The type of resource associated with this error.
				Resource *string `json:"resource,omitempty"`
			} `json:"errors,omitempty"`

			// Message The message of the fault.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetActivityStreamsResponse parses an HTTP response from a GetActivityStreamsWithResponse call
func ParseGetActivityStreamsResponse(rsp *http.Response) (*GetActivityStreamsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetActivityStreamsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Altitude *struct {
				// Data The sequence of altitude values for this stream, in meters
				Data *[]float32 `json:"data,omitempty"`

				// OriginalSize The number of data points in this stream
				OriginalSize *int `json:"original_size,omitempty"`

				// Resolution The level of detail (sampling) in which this stream was returned
				Resolution *GetActivityStreams200AltitudeResolution `json:"resolution,omitempty"`

				// SeriesType The base series used in the case the stream was downsampled
				SeriesType *GetActivityStreams200AltitudeSeriesType `json:"series_type,omitempty"`
			} `json:"altitude,omitempty"`
			Cadence *struct {
				// Data The sequence of cadence values for this stream, in rotations per minute
				Data *[]int `json:"data,omitempty"`

				// OriginalSize The number of data points in this stream
				OriginalSize *int `json:"original_size,omitempty"`

				// Resolution The level of detail (sampling) in which this stream was returned
				Resolution *GetActivityStreams200CadenceResolution `json:"resolution,omitempty"`

				// SeriesType The base series used in the case the stream was downsampled
				SeriesType *GetActivityStreams200CadenceSeriesType `json:"series_type,omitempty"`
			} `json:"cadence,omitempty"`
			Distance *struct {
				// Data The sequence of distance values for this stream, in meters
				Data *[]float32 `json:"data,omitempty"`

				// OriginalSize The number of data points in this stream
				OriginalSize *int `json:"original_size,omitempty"`

				// Resolution The level of detail (sampling) in which this stream was returned
				Resolution *GetActivityStreams200DistanceResolution `json:"resolution,omitempty"`

				// SeriesType The base series used in the case the stream was downsampled
				SeriesType *GetActivityStreams200DistanceSeriesType `json:"series_type,omitempty"`
			} `json:"distance,omitempty"`
			GradeSmooth *struct {
				// Data The sequence of grade values for this stream, as percents of a grade
				Data *[]float32 `json:"data,omitempty"`

				// OriginalSize The number of data points in this stream
				OriginalSize *int `json:"original_size,omitempty"`

				// Resolution The level of detail (sampling) in which this stream was returned
				Resolution *GetActivityStreams200GradeSmoothResolution `json:"resolution,omitempty"`

				// SeriesType The base series used in the case the stream was downsampled
				SeriesType *GetActivityStreams200GradeSmoothSeriesType `json:"series_type,omitempty"`
			} `json:"grade_smooth,omitempty"`
			Heartrate *struct {
				// Data The sequence of heart rate values for this stream, in beats per minute
				Data *[]int `json:"data,omitempty"`

				// OriginalSize The number of data points in this stream
				OriginalSize *int `json:"original_size,omitempty"`

				// Resolution The level of detail (sampling) in which this stream was returned
				Resolution *GetActivityStreams200HeartrateResolution `json:"resolution,omitempty"`

				// SeriesType The base series used in the case the stream was downsampled
				SeriesType *GetActivityStreams200HeartrateSeriesType `json:"series_type,omitempty"`
			} `json:"heartrate,omitempty"`
			Latlng *struct {
				// Data The sequence of lat/long values for this stream
				Data *[][]float32 `json:"data,omitempty"`

				// OriginalSize The number of data points in this stream
				OriginalSize *int `json:"original_size,omitempty"`

				// Resolution The level of detail (sampling) in which this stream was returned
				Resolution *GetActivityStreams200LatlngResolution `json:"resolution,omitempty"`

				// SeriesType The base series used in the case the stream was downsampled
				SeriesType *GetActivityStreams200LatlngSeriesType `json:"series_type,omitempty"`
			} `json:"latlng,omitempty"`
			Moving *struct {
				// Data The sequence of moving values for this stream, as boolean values
				Data *[]bool `json:"data,omitempty"`

				// OriginalSize The number of data points in this stream
				OriginalSize *int `json:"original_size,omitempty"`

				// Resolution The level of detail (sampling) in which this stream was returned
				Resolution *GetActivityStreams200MovingResolution `json:"resolution,omitempty"`

				// SeriesType The base series used in the case the stream was downsampled
				SeriesType *GetActivityStreams200MovingSeriesType `json:"series_type,omitempty"`
			} `json:"moving,omitempty"`
			Temp *struct {
				// Data The sequence of temperature values for this stream, in celsius degrees
				Data *[]int `json:"data,omitempty"`

				// OriginalSize The number of data points in this stream
				OriginalSize *int `json:"original_size,omitempty"`

				// Resolution The level of detail (sampling) in which this stream was returned
				Resolution *GetActivityStreams200TempResolution `json:"resolution,omitempty"`

				// SeriesType The base series used in the case the stream was downsampled
				SeriesType *GetActivityStreams200TempSeriesType `json:"series_type,omitempty"`
			} `json:"temp,omitempty"`
			Time *struct {
				// Data The sequence of time values for this stream, in seconds
				Data *[]int `json:"data,omitempty"`

				// OriginalSize The number of data points in this stream
				OriginalSize *int `json:"original_size,omitempty"`

				// Resolution The level of detail (sampling) in which this stream was returned
				Resolution *GetActivityStreams200TimeResolution `json:"resolution,omitempty"`

				// SeriesType The base series used in the case the stream was downsampled
				SeriesType *GetActivityStreams200TimeSeriesType `json:"series_type,omitempty"`
			} `json:"time,omitempty"`
			VelocitySmooth *struct {
				// Data The sequence of velocity values for this stream, in meters per second
				Data *[]float32 `json:"data,omitempty"`

				// OriginalSize The number of data points in this stream
				OriginalSize *int `json:"original_size,omitempty"`

				// Resolution The level of detail (sampling) in which this stream was returned
				Resolution *GetActivityStreams200VelocitySmoothResolution `json:"resolution,omitempty"`

				// SeriesType The base series used in the case the stream was downsampled
				SeriesType *GetActivityStreams200VelocitySmoothSeriesType `json:"series_type,omitempty"`
			} `json:"velocity_smooth,omitempty"`
			Watts *struct {
				// Data The sequence of power values for this stream, in watts
				Data *[]int `json:"data,omitempty"`

				// OriginalSize The number of data points in this stream
				OriginalSize *int `json:"original_size,omitempty"`

				// Resolution The level of detail (sampling) in which this stream was returned
				Resolution *GetActivityStreams200WattsResolution `json:"resolution,omitempty"`

				// SeriesType The base series used in the case the stream was downsampled
				SeriesType *GetActivityStreams200WattsSeriesType `json:"series_type,omitempty"`
			} `json:"watts,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			// Errors The set of specific errors associated with this fault, if any.
			Errors *[]struct {
				// Code The code associated with this error.
				Code *string `json:"code,omitempty"`

				// Field The specific field or aspect of the resource associated with this error.
				Field *string `json:"field,omitempty"`

				// Resource The type of resource associated with this error.
				Resource *string `json:"resource,omitempty"`
			} `json:"errors,omitempty"`

			// Message The message of the fault.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetZonesByActivityIdResponse parses an HTTP response from a GetZonesByActivityIdWithResponse call
func ParseGetZonesByActivityIdResponse(rsp *http.Response) (*GetZonesByActivityIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetZonesByActivityIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			CustomZones *bool `json:"custom_zones,omitempty"`

			// DistributionBuckets Stores the exclusive ranges representing zones and the time spent in each.
			DistributionBuckets *[]struct {
				// Max The maximum value in the range.
				Max *int `json:"max,omitempty"`

				// Min The minimum value in the range.
				Min *int `json:"min,omitempty"`

				// Time The number of seconds spent in this zone
				Time *int `json:"time,omitempty"`
			} `json:"distribution_buckets,omitempty"`
			Max         *int                         `json:"max,omitempty"`
			Points      *int                         `json:"points,omitempty"`
			Score       *int                         `json:"score,omitempty"`
			SensorBased *bool                        `json:"sensor_based,omitempty"`
			Type        *GetZonesByActivityId200Type `json:"type,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			// Errors The set of specific errors associated with this fault, if any.
			Errors *[]struct {
				// Code The code associated with this error.
				Code *string `json:"code,omitempty"`

				// Field The specific field or aspect of the resource associated with this error.
				Field *string `json:"field,omitempty"`

				// Resource The type of resource associated with this error.
				Resource *string `json:"resource,omitempty"`
			} `json:"errors,omitempty"`

			// Message The message of the fault.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetLoggedInAthleteResponse parses an HTTP response from a GetLoggedInAthleteWithResponse call
func ParseGetLoggedInAthleteResponse(rsp *http.Response) (*GetLoggedInAthleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLoggedInAthleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Bikes The athlete's bikes.
			Bikes *[]struct {
				// Distance The distance logged with this gear.
				Distance *float32 `json:"distance,omitempty"`

				// Id The gear's unique identifier.
				Id *string `json:"id,omitempty"`

				// Name The gear's name.
				Name *string `json:"name,omitempty"`

				// Primary Whether this gear's is the owner's default one.
				Primary *bool `json:"primary,omitempty"`

				// ResourceState Resource state, indicates level of detail. Possible values: 2 -> "summary", 3 -> "detail"
				ResourceState *int `json:"resource_state,omitempty"`
			} `json:"bikes,omitempty"`

			// City The athlete's city.
			City *string `json:"city,omitempty"`

			// Clubs The athlete's clubs.
			Clubs *[]struct {
				// ActivityTypes The activity types that count for a club. This takes precedence over sport_type.
				ActivityTypes *[]GetLoggedInAthlete200ClubsActivityTypes `json:"activity_types,omitempty"`

				// City The club's city.
				City *string `json:"city,omitempty"`

				// Country The club's country.
				Country *string `json:"country,omitempty"`

				// CoverPhoto URL to a ~1185x580 pixel cover photo.
				CoverPhoto *string `json:"cover_photo,omitempty"`

				// CoverPhotoSmall URL to a ~360x176  pixel cover photo.
				CoverPhotoSmall *string `json:"cover_photo_small,omitempty"`

				// Featured Whether the club is featured or not.
				Featured *bool `json:"featured,omitempty"`

				// Id The club's unique identifier.
				Id *int64 `json:"id,omitempty"`

				// MemberCount The club's member count.
				MemberCount *int `json:"member_count,omitempty"`

				// Name The club's name.
				Name *string `json:"name,omitempty"`

				// Private Whether the club is private.
				Private *bool `json:"private,omitempty"`

				// ProfileMedium URL to a 60x60 pixel profile picture.
				ProfileMedium *string `json:"profile_medium,omitempty"`

				// ResourceState Resource state, indicates level of detail. Possible values: 1 -> "meta", 2 -> "summary", 3 -> "detail"
				ResourceState *int `json:"resource_state,omitempty"`

				// SportType Deprecated. Prefer to use activity_types.
				SportType *GetLoggedInAthlete200ClubsSportType `json:"sport_type,omitempty"`

				// State The club's state or geographical region.
				State *string `json:"state,omitempty"`

				// Url The club's vanity URL.
				Url *string `json:"url,omitempty"`

				// Verified Whether the club is verified or not.
				Verified *bool `json:"verified,omitempty"`
			} `json:"clubs,omitempty"`

			// Country The athlete's country.
			Country *string `json:"country,omitempty"`

			// CreatedAt The time at which the athlete was created.
			CreatedAt *time.Time `json:"created_at,omitempty"`

			// Firstname The athlete's first name.
			Firstname *string `json:"firstname,omitempty"`

			// FollowerCount The athlete's follower count.
			FollowerCount *int `json:"follower_count,omitempty"`

			// FriendCount The athlete's friend count.
			FriendCount *int `json:"friend_count,omitempty"`

			// Ftp The athlete's FTP (Functional Threshold Power).
			Ftp *int `json:"ftp,omitempty"`

			// Id The unique identifier of the athlete
			Id *int64 `json:"id,omitempty"`

			// Lastname The athlete's last name.
			Lastname *string `json:"lastname,omitempty"`

			// MeasurementPreference The athlete's preferred unit system.
			MeasurementPreference *GetLoggedInAthlete200MeasurementPreference `json:"measurement_preference,omitempty"`

			// Premium Deprecated.  Use summit field instead. Whether the athlete has any Summit subscription.
			Premium *bool `json:"premium,omitempty"`

			// Profile URL to a 124x124 pixel profile picture.
			Profile *string `json:"profile,omitempty"`

			// ProfileMedium URL to a 62x62 pixel profile picture.
			ProfileMedium *string `json:"profile_medium,omitempty"`

			// ResourceState Resource state, indicates level of detail. Possible values: 1 -> "meta", 2 -> "summary", 3 -> "detail"
			ResourceState *int `json:"resource_state,omitempty"`

			// Sex The athlete's sex.
			Sex *GetLoggedInAthlete200Sex `json:"sex,omitempty"`

			// Shoes The athlete's shoes.
			Shoes *[]struct {
				// Distance The distance logged with this gear.
				Distance *float32 `json:"distance,omitempty"`

				// Id The gear's unique identifier.
				Id *string `json:"id,omitempty"`

				// Name The gear's name.
				Name *string `json:"name,omitempty"`

				// Primary Whether this gear's is the owner's default one.
				Primary *bool `json:"primary,omitempty"`

				// ResourceState Resource state, indicates level of detail. Possible values: 2 -> "summary", 3 -> "detail"
				ResourceState *int `json:"resource_state,omitempty"`
			} `json:"shoes,omitempty"`

			// State The athlete's state or geographical region.
			State *string `json:"state,omitempty"`

			// Summit Whether the athlete has any Summit subscription.
			Summit *bool `json:"summit,omitempty"`

			// UpdatedAt The time at which the athlete was last updated.
			UpdatedAt *time.Time `json:"updated_at,omitempty"`

			// Weight The athlete's weight.
			Weight *float32 `json:"weight,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			// Errors The set of specific errors associated with this fault, if any.
			Errors *[]struct {
				// Code The code associated with this error.
				Code *string `json:"code,omitempty"`

				// Field The specific field or aspect of the resource associated with this error.
				Field *string `json:"field,omitempty"`

				// Resource The type of resource associated with this error.
				Resource *string `json:"resource,omitempty"`
			} `json:"errors,omitempty"`

			// Message The message of the fault.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetLoggedInAthleteActivitiesResponse parses an HTTP response from a GetLoggedInAthleteActivitiesWithResponse call
func ParseGetLoggedInAthleteActivitiesResponse(rsp *http.Response) (*GetLoggedInAthleteActivitiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLoggedInAthleteActivitiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			// AchievementCount The number of achievements gained during this activity
			AchievementCount *int `json:"achievement_count,omitempty"`
			Athlete          *struct {
				// Id The unique identifier of the athlete
				Id *int64 `json:"id,omitempty"`
			} `json:"athlete,omitempty"`

			// AthleteCount The number of athletes for taking part in a group activity
			AthleteCount *int `json:"athlete_count,omitempty"`

			// AverageSpeed The activity's average speed, in meters per second
			AverageSpeed *float32 `json:"average_speed,omitempty"`

			// AverageWatts Average power output in watts during this activity. Rides only
			AverageWatts *float32 `json:"average_watts,omitempty"`

			// CommentCount The number of comments for this activity
			CommentCount *int `json:"comment_count,omitempty"`

			// Commute Whether this activity is a commute
			Commute *bool `json:"commute,omitempty"`

			// DeviceName The name of the device used to record the activity
			DeviceName *string `json:"device_name,omitempty"`

			// DeviceWatts Whether the watts are from a power meter, false if estimated
			DeviceWatts *bool `json:"device_watts,omitempty"`

			// Distance The activity's distance, in meters
			Distance *float32 `json:"distance,omitempty"`

			// ElapsedTime The activity's elapsed time, in seconds
			ElapsedTime *int `json:"elapsed_time,omitempty"`

			// ElevHigh The activity's highest elevation, in meters
			ElevHigh *float32 `json:"elev_high,omitempty"`

			// ElevLow The activity's lowest elevation, in meters
			ElevLow *float32 `json:"elev_low,omitempty"`

			// EndLatlng A pair of latitude/longitude coordinates, represented as an array of 2 floating point numbers.
			EndLatlng *[]float32 `json:"end_latlng,omitempty"`

			// ExternalId The identifier provided at upload time
			ExternalId *string `json:"external_id,omitempty"`

			// Flagged Whether this activity is flagged
			Flagged *bool `json:"flagged,omitempty"`

			// GearId The id of the gear for the activity
			GearId *string `json:"gear_id,omitempty"`

			// HasKudoed Whether the logged-in athlete has kudoed this activity
			HasKudoed *bool `json:"has_kudoed,omitempty"`

			// HideFromHome Whether the activity is muted
			HideFromHome *bool `json:"hide_from_home,omitempty"`

			// Id The unique identifier of the activity
			Id *int64 `json:"id,omitempty"`

			// Kilojoules The total work done in kilojoules during this activity. Rides only
			Kilojoules *float32 `json:"kilojoules,omitempty"`

			// KudosCount The number of kudos given for this activity
			KudosCount *int `json:"kudos_count,omitempty"`

			// Manual Whether this activity was created manually
			Manual *bool `json:"manual,omitempty"`
			Map    *struct {
				// Id The identifier of the map
				Id *string `json:"id,omitempty"`

				// Polyline The polyline of the map, only returned on detailed representation of an object
				Polyline *string `json:"polyline,omitempty"`

				// SummaryPolyline The summary polyline of the map
				SummaryPolyline *string `json:"summary_polyline,omitempty"`
			} `json:"map,omitempty"`

			// MaxSpeed The activity's max speed, in meters per second
			MaxSpeed *float32 `json:"max_speed,omitempty"`

			// MaxWatts Rides with power meter data only
			MaxWatts *int `json:"max_watts,omitempty"`

			// MovingTime The activity's moving time, in seconds
			MovingTime *int `json:"moving_time,omitempty"`

			// Name The name of the activity
			Name *string `json:"name,omitempty"`

			// PhotoCount The number of Instagram photos for this activity
			PhotoCount *int `json:"photo_count,omitempty"`

			// Private Whether this activity is private
			Private *bool `json:"private,omitempty"`

			// SportType An enumeration of the sport types an activity may have. Distinct from ActivityType in that it has new types (e.g. MountainBikeRide)
			SportType *GetLoggedInAthleteActivities200SportType `json:"sport_type,omitempty"`

			// StartDate The time at which the activity was started.
			StartDate *time.Time `json:"start_date,omitempty"`

			// StartDateLocal The time at which the activity was started in the local timezone.
			StartDateLocal *time.Time `json:"start_date_local,omitempty"`

			// StartLatlng A pair of latitude/longitude coordinates, represented as an array of 2 floating point numbers.
			StartLatlng *[]float32 `json:"start_latlng,omitempty"`

			// Timezone The timezone of the activity
			Timezone *string `json:"timezone,omitempty"`

			// TotalElevationGain The activity's total elevation gain.
			TotalElevationGain *float32 `json:"total_elevation_gain,omitempty"`

			// TotalPhotoCount The number of Instagram and Strava photos for this activity
			TotalPhotoCount *int `json:"total_photo_count,omitempty"`

			// Trainer Whether this activity was recorded on a training machine
			Trainer *bool `json:"trainer,omitempty"`

			// Type Deprecated. Prefer to use sport_type
			Type *GetLoggedInAthleteActivities200Type `json:"type,omitempty"`

			// UploadId The identifier of the upload that resulted in this activity
			UploadId *int64 `json:"upload_id,omitempty"`

			// UploadIdStr The unique identifier of the upload in string format
			UploadIdStr *string `json:"upload_id_str,omitempty"`

			// WeightedAverageWatts Similar to Normalized Power. Rides with power meter data only
			WeightedAverageWatts *int `json:"weighted_average_watts,omitempty"`

			// WorkoutType The activity's workout type
			WorkoutType *int `json:"workout_type,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			// Errors The set of specific errors associated with this fault, if any.
			Errors *[]struct {
				// Code The code associated with this error.
				Code *string `json:"code,omitempty"`

				// Field The specific field or aspect of the resource associated with this error.
				Field *string `json:"field,omitempty"`

				// Resource The type of resource associated with this error.
				Resource *string `json:"resource,omitempty"`
			} `json:"errors,omitempty"`

			// Message The message of the fault.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetLoggedInAthleteClubsResponse parses an HTTP response from a GetLoggedInAthleteClubsWithResponse call
func ParseGetLoggedInAthleteClubsResponse(rsp *http.Response) (*GetLoggedInAthleteClubsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLoggedInAthleteClubsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			// ActivityTypes The activity types that count for a club. This takes precedence over sport_type.
			ActivityTypes *[]GetLoggedInAthleteClubs200ActivityTypes `json:"activity_types,omitempty"`

			// City The club's city.
			City *string `json:"city,omitempty"`

			// Country The club's country.
			Country *string `json:"country,omitempty"`

			// CoverPhoto URL to a ~1185x580 pixel cover photo.
			CoverPhoto *string `json:"cover_photo,omitempty"`

			// CoverPhotoSmall URL to a ~360x176  pixel cover photo.
			CoverPhotoSmall *string `json:"cover_photo_small,omitempty"`

			// Featured Whether the club is featured or not.
			Featured *bool `json:"featured,omitempty"`

			// Id The club's unique identifier.
			Id *int64 `json:"id,omitempty"`

			// MemberCount The club's member count.
			MemberCount *int `json:"member_count,omitempty"`

			// Name The club's name.
			Name *string `json:"name,omitempty"`

			// Private Whether the club is private.
			Private *bool `json:"private,omitempty"`

			// ProfileMedium URL to a 60x60 pixel profile picture.
			ProfileMedium *string `json:"profile_medium,omitempty"`

			// ResourceState Resource state, indicates level of detail. Possible values: 1 -> "meta", 2 -> "summary", 3 -> "detail"
			ResourceState *int `json:"resource_state,omitempty"`

			// SportType Deprecated. Prefer to use activity_types.
			SportType *GetLoggedInAthleteClubs200SportType `json:"sport_type,omitempty"`

			// State The club's state or geographical region.
			State *string `json:"state,omitempty"`

			// Url The club's vanity URL.
			Url *string `json:"url,omitempty"`

			// Verified Whether the club is verified or not.
			Verified *bool `json:"verified,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			// Errors The set of specific errors associated with this fault, if any.
			Errors *[]struct {
				// Code The code associated with this error.
				Code *string `json:"code,omitempty"`

				// Field The specific field or aspect of the resource associated with this error.
				Field *string `json:"field,omitempty"`

				// Resource The type of resource associated with this error.
				Resource *string `json:"resource,omitempty"`
			} `json:"errors,omitempty"`

			// Message The message of the fault.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetLoggedInAthleteZonesResponse parses an HTTP response from a GetLoggedInAthleteZonesWithResponse call
func ParseGetLoggedInAthleteZonesResponse(rsp *http.Response) (*GetLoggedInAthleteZonesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLoggedInAthleteZonesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			HeartRate *struct {
				// CustomZones Whether the athlete has set their own custom heart rate zones
				CustomZones *bool `json:"custom_zones,omitempty"`
				Zones       *[]struct {
					// Max The maximum value in the range.
					Max *int `json:"max,omitempty"`

					// Min The minimum value in the range.
					Min *int `json:"min,omitempty"`
				} `json:"zones,omitempty"`
			} `json:"heart_rate,omitempty"`
			Power *struct {
				Zones *[]struct {
					// Max The maximum value in the range.
					Max *int `json:"max,omitempty"`

					// Min The minimum value in the range.
					Min *int `json:"min,omitempty"`
				} `json:"zones,omitempty"`
			} `json:"power,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			// Errors The set of specific errors associated with this fault, if any.
			Errors *[]struct {
				// Code The code associated with this error.
				Code *string `json:"code,omitempty"`

				// Field The specific field or aspect of the resource associated with this error.
				Field *string `json:"field,omitempty"`

				// Resource The type of resource associated with this error.
				Resource *string `json:"resource,omitempty"`
			} `json:"errors,omitempty"`

			// Message The message of the fault.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetRoutesByAthleteIdResponse parses an HTTP response from a GetRoutesByAthleteIdWithResponse call
func ParseGetRoutesByAthleteIdResponse(rsp *http.Response) (*GetRoutesByAthleteIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRoutesByAthleteIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			Athlete *struct {
				// City The athlete's city.
				City *string `json:"city,omitempty"`

				// Country The athlete's country.
				Country *string `json:"country,omitempty"`

				// CreatedAt The time at which the athlete was created.
				CreatedAt *time.Time `json:"created_at,omitempty"`

				// Firstname The athlete's first name.
				Firstname *string `json:"firstname,omitempty"`

				// Id The unique identifier of the athlete
				Id *int64 `json:"id,omitempty"`

				// Lastname The athlete's last name.
				Lastname *string `json:"lastname,omitempty"`

				// Premium Deprecated.  Use summit field instead. Whether the athlete has any Summit subscription.
				Premium *bool `json:"premium,omitempty"`

				// Profile URL to a 124x124 pixel profile picture.
				Profile *string `json:"profile,omitempty"`

				// ProfileMedium URL to a 62x62 pixel profile picture.
				ProfileMedium *string `json:"profile_medium,omitempty"`

				// ResourceState Resource state, indicates level of detail. Possible values: 1 -> "meta", 2 -> "summary", 3 -> "detail"
				ResourceState *int `json:"resource_state,omitempty"`

				// Sex The athlete's sex.
				Sex *GetRoutesByAthleteId200AthleteSex `json:"sex,omitempty"`

				// State The athlete's state or geographical region.
				State *string `json:"state,omitempty"`

				// Summit Whether the athlete has any Summit subscription.
				Summit *bool `json:"summit,omitempty"`

				// UpdatedAt The time at which the athlete was last updated.
				UpdatedAt *time.Time `json:"updated_at,omitempty"`
			} `json:"athlete,omitempty"`

			// CreatedAt The time at which the route was created
			CreatedAt *time.Time `json:"created_at,omitempty"`

			// Description The description of the route
			Description *string `json:"description,omitempty"`

			// Distance The route's distance, in meters
			Distance *float32 `json:"distance,omitempty"`

			// ElevationGain The route's elevation gain.
			ElevationGain *float32 `json:"elevation_gain,omitempty"`

			// EstimatedMovingTime Estimated time in seconds for the authenticated athlete to complete route
			EstimatedMovingTime *int `json:"estimated_moving_time,omitempty"`

			// Id The unique identifier of this route
			Id *int64 `json:"id,omitempty"`

			// IdStr The unique identifier of the route in string format
			IdStr *string `json:"id_str,omitempty"`
			Map   *struct {
				// Id The identifier of the map
				Id *string `json:"id,omitempty"`

				// Polyline The polyline of the map, only returned on detailed representation of an object
				Polyline *string `json:"polyline,omitempty"`

				// SummaryPolyline The summary polyline of the map
				SummaryPolyline *string `json:"summary_polyline,omitempty"`
			} `json:"map,omitempty"`

			// Name The name of this route
			Name *string `json:"name,omitempty"`

			// Private Whether this route is private
			Private *bool `json:"private,omitempty"`

			// Segments The segments traversed by this route
			Segments *[]struct {
				ActivityType    *GetRoutesByAthleteId200SegmentsActivityType `json:"activity_type,omitempty"`
				AthletePrEffort *struct {
					// EffortCount Number of efforts by the authenticated athlete on this segment.
					EffortCount *int `json:"effort_count,omitempty"`

					// PrActivityId The unique identifier of the activity related to the PR effort.
					PrActivityId *int64 `json:"pr_activity_id,omitempty"`

					// PrDate The time at which the PR effort was started.
					PrDate *time.Time `json:"pr_date,omitempty"`

					// PrElapsedTime The elapsed time ot the PR effort.
					PrElapsedTime *int `json:"pr_elapsed_time,omitempty"`
				} `json:"athlete_pr_effort,omitempty"`
				AthleteSegmentStats *struct {
					// ActivityId The unique identifier of the activity related to this effort
					ActivityId *int64 `json:"activity_id,omitempty"`

					// Distance The effort's distance in meters
					Distance *float32 `json:"distance,omitempty"`

					// ElapsedTime The effort's elapsed time
					ElapsedTime *int `json:"elapsed_time,omitempty"`

					// Id The unique identifier of this effort
					Id *int64 `json:"id,omitempty"`

					// IsKom Whether this effort is the current best on the leaderboard
					IsKom *bool `json:"is_kom,omitempty"`

					// StartDate The time at which the effort was started.
					StartDate *time.Time `json:"start_date,omitempty"`

					// StartDateLocal The time at which the effort was started in the local timezone.
					StartDateLocal *time.Time `json:"start_date_local,omitempty"`
				} `json:"athlete_segment_stats,omitempty"`

				// AverageGrade The segment's average grade, in percents
				AverageGrade *float32 `json:"average_grade,omitempty"`

				// City The segments's city.
				City *string `json:"city,omitempty"`

				// ClimbCategory The category of the climb [0, 5]. Higher is harder ie. 5 is Hors catgorie, 0 is uncategorized in climb_category.
				ClimbCategory *int `json:"climb_category,omitempty"`

				// Country The segment's country.
				Country *string `json:"country,omitempty"`

				// Distance The segment's distance, in meters
				Distance *float32 `json:"distance,omitempty"`

				// ElevationHigh The segments's highest elevation, in meters
				ElevationHigh *float32 `json:"elevation_high,omitempty"`

				// ElevationLow The segments's lowest elevation, in meters
				ElevationLow *float32 `json:"elevation_low,omitempty"`

				// EndLatlng A pair of latitude/longitude coordinates, represented as an array of 2 floating point numbers.
				EndLatlng *[]float32 `json:"end_latlng,omitempty"`

				// Id The unique identifier of this segment
				Id *int64 `json:"id,omitempty"`

				// MaximumGrade The segments's maximum grade, in percents
				MaximumGrade *float32 `json:"maximum_grade,omitempty"`

				// Name The name of this segment
				Name *string `json:"name,omitempty"`

				// Private Whether this segment is private.
				Private *bool `json:"private,omitempty"`

				// StartLatlng A pair of latitude/longitude coordinates, represented as an array of 2 floating point numbers.
				StartLatlng *[]float32 `json:"start_latlng,omitempty"`

				// State The segments's state or geographical region.
				State *string `json:"state,omitempty"`
			} `json:"segments,omitempty"`

			// Starred Whether this route is starred by the logged-in athlete
			Starred *bool `json:"starred,omitempty"`

			// SubType This route's sub-type (1 for road, 2 for mountain bike, 3 for cross, 4 for trail, 5 for mixed)
			SubType *int `json:"sub_type,omitempty"`

			// Timestamp An epoch timestamp of when the route was created
			Timestamp *int `json:"timestamp,omitempty"`

			// Type This route's type (1 for ride, 2 for runs)
			Type *int `json:"type,omitempty"`

			// UpdatedAt The time at which the route was last updated
			UpdatedAt *time.Time `json:"updated_at,omitempty"`

			// Waypoints The custom waypoints along this route
			Waypoints *[]struct {
				// Categories Categories that the waypoint belongs to
				Categories *[]string `json:"categories,omitempty"`

				// Description A description of the waypoint (optional)
				Description *string `json:"description,omitempty"`

				// DistanceIntoRoute The number meters along the route that the waypoint is located
				DistanceIntoRoute *float32 `json:"distance_into_route,omitempty"`

				// Latlng The location along the route that the waypoint is closest to
				Latlng *[]float32 `json:"latlng,omitempty"`

				// TargetLatlng A location off of the route that the waypoint is (optional)
				TargetLatlng *[]float32 `json:"target_latlng,omitempty"`

				// Title A title for the waypoint
				Title *string `json:"title,omitempty"`
			} `json:"waypoints,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			// Errors The set of specific errors associated with this fault, if any.
			Errors *[]struct {
				// Code The code associated with this error.
				Code *string `json:"code,omitempty"`

				// Field The specific field or aspect of the resource associated with this error.
				Field *string `json:"field,omitempty"`

				// Resource The type of resource associated with this error.
				Resource *string `json:"resource,omitempty"`
			} `json:"errors,omitempty"`

			// Message The message of the fault.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetStatsResponse parses an HTTP response from a GetStatsWithResponse call
func ParseGetStatsResponse(rsp *http.Response) (*GetStatsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStatsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AllRideTotals The all time ride stats for the athlete.
			AllRideTotals *struct {
				// AchievementCount The total number of achievements of the considered activities.
				AchievementCount *int `json:"achievement_count,omitempty"`

				// Count The number of activities considered in this total.
				Count *int `json:"count,omitempty"`

				// Distance The total distance covered by the considered activities.
				Distance *float32 `json:"distance,omitempty"`

				// ElapsedTime The total elapsed time of the considered activities.
				ElapsedTime *int `json:"elapsed_time,omitempty"`

				// ElevationGain The total elevation gain of the considered activities.
				ElevationGain *float32 `json:"elevation_gain,omitempty"`

				// MovingTime The total moving time of the considered activities.
				MovingTime *int `json:"moving_time,omitempty"`
			} `json:"all_ride_totals,omitempty"`

			// AllRunTotals The all time run stats for the athlete.
			AllRunTotals *struct {
				// AchievementCount The total number of achievements of the considered activities.
				AchievementCount *int `json:"achievement_count,omitempty"`

				// Count The number of activities considered in this total.
				Count *int `json:"count,omitempty"`

				// Distance The total distance covered by the considered activities.
				Distance *float32 `json:"distance,omitempty"`

				// ElapsedTime The total elapsed time of the considered activities.
				ElapsedTime *int `json:"elapsed_time,omitempty"`

				// ElevationGain The total elevation gain of the considered activities.
				ElevationGain *float32 `json:"elevation_gain,omitempty"`

				// MovingTime The total moving time of the considered activities.
				MovingTime *int `json:"moving_time,omitempty"`
			} `json:"all_run_totals,omitempty"`

			// AllSwimTotals The all time swim stats for the athlete.
			AllSwimTotals *struct {
				// AchievementCount The total number of achievements of the considered activities.
				AchievementCount *int `json:"achievement_count,omitempty"`

				// Count The number of activities considered in this total.
				Count *int `json:"count,omitempty"`

				// Distance The total distance covered by the considered activities.
				Distance *float32 `json:"distance,omitempty"`

				// ElapsedTime The total elapsed time of the considered activities.
				ElapsedTime *int `json:"elapsed_time,omitempty"`

				// ElevationGain The total elevation gain of the considered activities.
				ElevationGain *float32 `json:"elevation_gain,omitempty"`

				// MovingTime The total moving time of the considered activities.
				MovingTime *int `json:"moving_time,omitempty"`
			} `json:"all_swim_totals,omitempty"`

			// BiggestClimbElevationGain The highest climb ridden by the athlete.
			BiggestClimbElevationGain *float64 `json:"biggest_climb_elevation_gain,omitempty"`

			// BiggestRideDistance The longest distance ridden by the athlete.
			BiggestRideDistance *float64 `json:"biggest_ride_distance,omitempty"`

			// RecentRideTotals The recent (last 4 weeks) ride stats for the athlete.
			RecentRideTotals *struct {
				// AchievementCount The total number of achievements of the considered activities.
				AchievementCount *int `json:"achievement_count,omitempty"`

				// Count The number of activities considered in this total.
				Count *int `json:"count,omitempty"`

				// Distance The total distance covered by the considered activities.
				Distance *float32 `json:"distance,omitempty"`

				// ElapsedTime The total elapsed time of the considered activities.
				ElapsedTime *int `json:"elapsed_time,omitempty"`

				// ElevationGain The total elevation gain of the considered activities.
				ElevationGain *float32 `json:"elevation_gain,omitempty"`

				// MovingTime The total moving time of the considered activities.
				MovingTime *int `json:"moving_time,omitempty"`
			} `json:"recent_ride_totals,omitempty"`

			// RecentRunTotals The recent (last 4 weeks) run stats for the athlete.
			RecentRunTotals *struct {
				// AchievementCount The total number of achievements of the considered activities.
				AchievementCount *int `json:"achievement_count,omitempty"`

				// Count The number of activities considered in this total.
				Count *int `json:"count,omitempty"`

				// Distance The total distance covered by the considered activities.
				Distance *float32 `json:"distance,omitempty"`

				// ElapsedTime The total elapsed time of the considered activities.
				ElapsedTime *int `json:"elapsed_time,omitempty"`

				// ElevationGain The total elevation gain of the considered activities.
				ElevationGain *float32 `json:"elevation_gain,omitempty"`

				// MovingTime The total moving time of the considered activities.
				MovingTime *int `json:"moving_time,omitempty"`
			} `json:"recent_run_totals,omitempty"`

			// RecentSwimTotals The recent (last 4 weeks) swim stats for the athlete.
			RecentSwimTotals *struct {
				// AchievementCount The total number of achievements of the considered activities.
				AchievementCount *int `json:"achievement_count,omitempty"`

				// Count The number of activities considered in this total.
				Count *int `json:"count,omitempty"`

				// Distance The total distance covered by the considered activities.
				Distance *float32 `json:"distance,omitempty"`

				// ElapsedTime The total elapsed time of the considered activities.
				ElapsedTime *int `json:"elapsed_time,omitempty"`

				// ElevationGain The total elevation gain of the considered activities.
				ElevationGain *float32 `json:"elevation_gain,omitempty"`

				// MovingTime The total moving time of the considered activities.
				MovingTime *int `json:"moving_time,omitempty"`
			} `json:"recent_swim_totals,omitempty"`

			// YtdRideTotals The year to date ride stats for the athlete.
			YtdRideTotals *struct {
				// AchievementCount The total number of achievements of the considered activities.
				AchievementCount *int `json:"achievement_count,omitempty"`

				// Count The number of activities considered in this total.
				Count *int `json:"count,omitempty"`

				// Distance The total distance covered by the considered activities.
				Distance *float32 `json:"distance,omitempty"`

				// ElapsedTime The total elapsed time of the considered activities.
				ElapsedTime *int `json:"elapsed_time,omitempty"`

				// ElevationGain The total elevation gain of the considered activities.
				ElevationGain *float32 `json:"elevation_gain,omitempty"`

				// MovingTime The total moving time of the considered activities.
				MovingTime *int `json:"moving_time,omitempty"`
			} `json:"ytd_ride_totals,omitempty"`

			// YtdRunTotals The year to date run stats for the athlete.
			YtdRunTotals *struct {
				// AchievementCount The total number of achievements of the considered activities.
				AchievementCount *int `json:"achievement_count,omitempty"`

				// Count The number of activities considered in this total.
				Count *int `json:"count,omitempty"`

				// Distance The total distance covered by the considered activities.
				Distance *float32 `json:"distance,omitempty"`

				// ElapsedTime The total elapsed time of the considered activities.
				ElapsedTime *int `json:"elapsed_time,omitempty"`

				// ElevationGain The total elevation gain of the considered activities.
				ElevationGain *float32 `json:"elevation_gain,omitempty"`

				// MovingTime The total moving time of the considered activities.
				MovingTime *int `json:"moving_time,omitempty"`
			} `json:"ytd_run_totals,omitempty"`

			// YtdSwimTotals The year to date swim stats for the athlete.
			YtdSwimTotals *struct {
				// AchievementCount The total number of achievements of the considered activities.
				AchievementCount *int `json:"achievement_count,omitempty"`

				// Count The number of activities considered in this total.
				Count *int `json:"count,omitempty"`

				// Distance The total distance covered by the considered activities.
				Distance *float32 `json:"distance,omitempty"`

				// ElapsedTime The total elapsed time of the considered activities.
				ElapsedTime *int `json:"elapsed_time,omitempty"`

				// ElevationGain The total elevation gain of the considered activities.
				ElevationGain *float32 `json:"elevation_gain,omitempty"`

				// MovingTime The total moving time of the considered activities.
				MovingTime *int `json:"moving_time,omitempty"`
			} `json:"ytd_swim_totals,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			// Errors The set of specific errors associated with this fault, if any.
			Errors *[]struct {
				// Code The code associated with this error.
				Code *string `json:"code,omitempty"`

				// Field The specific field or aspect of the resource associated with this error.
				Field *string `json:"field,omitempty"`

				// Resource The type of resource associated with this error.
				Resource *string `json:"resource,omitempty"`
			} `json:"errors,omitempty"`

			// Message The message of the fault.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetClubByIdResponse parses an HTTP response from a GetClubByIdWithResponse call
func ParseGetClubByIdResponse(rsp *http.Response) (*GetClubByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClubByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// ActivityTypes The activity types that count for a club. This takes precedence over sport_type.
			ActivityTypes *[]GetClubById200ActivityTypes `json:"activity_types,omitempty"`

			// Admin Whether the currently logged-in athlete is an administrator of this club.
			Admin *bool `json:"admin,omitempty"`

			// City The club's city.
			City *string `json:"city,omitempty"`

			// Country The club's country.
			Country *string `json:"country,omitempty"`

			// CoverPhoto URL to a ~1185x580 pixel cover photo.
			CoverPhoto *string `json:"cover_photo,omitempty"`

			// CoverPhotoSmall URL to a ~360x176  pixel cover photo.
			CoverPhotoSmall *string `json:"cover_photo_small,omitempty"`

			// Featured Whether the club is featured or not.
			Featured *bool `json:"featured,omitempty"`

			// FollowingCount The number of athletes in the club that the logged-in athlete follows.
			FollowingCount *int `json:"following_count,omitempty"`

			// Id The club's unique identifier.
			Id *int64 `json:"id,omitempty"`

			// MemberCount The club's member count.
			MemberCount *int `json:"member_count,omitempty"`

			// Membership The membership status of the logged-in athlete.
			Membership *GetClubById200Membership `json:"membership,omitempty"`

			// Name The club's name.
			Name *string `json:"name,omitempty"`

			// Owner Whether the currently logged-in athlete is the owner of this club.
			Owner *bool `json:"owner,omitempty"`

			// Private Whether the club is private.
			Private *bool `json:"private,omitempty"`

			// ProfileMedium URL to a 60x60 pixel profile picture.
			ProfileMedium *string `json:"profile_medium,omitempty"`

			// ResourceState Resource state, indicates level of detail. Possible values: 1 -> "meta", 2 -> "summary", 3 -> "detail"
			ResourceState *int `json:"resource_state,omitempty"`

			// SportType Deprecated. Prefer to use activity_types.
			SportType *GetClubById200SportType `json:"sport_type,omitempty"`

			// State The club's state or geographical region.
			State *string `json:"state,omitempty"`

			// Url The club's vanity URL.
			Url *string `json:"url,omitempty"`

			// Verified Whether the club is verified or not.
			Verified *bool `json:"verified,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			// Errors The set of specific errors associated with this fault, if any.
			Errors *[]struct {
				// Code The code associated with this error.
				Code *string `json:"code,omitempty"`

				// Field The specific field or aspect of the resource associated with this error.
				Field *string `json:"field,omitempty"`

				// Resource The type of resource associated with this error.
				Resource *string `json:"resource,omitempty"`
			} `json:"errors,omitempty"`

			// Message The message of the fault.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetClubActivitiesByIdResponse parses an HTTP response from a GetClubActivitiesByIdWithResponse call
func ParseGetClubActivitiesByIdResponse(rsp *http.Response) (*GetClubActivitiesByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClubActivitiesByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			Athlete *struct {
				// Id The unique identifier of the athlete
				Id *int64 `json:"id,omitempty"`
			} `json:"athlete,omitempty"`

			// Distance The activity's distance, in meters
			Distance *float32 `json:"distance,omitempty"`

			// ElapsedTime The activity's elapsed time, in seconds
			ElapsedTime *int `json:"elapsed_time,omitempty"`

			// MovingTime The activity's moving time, in seconds
			MovingTime *int `json:"moving_time,omitempty"`

			// Name The name of the activity
			Name *string `json:"name,omitempty"`

			// SportType An enumeration of the sport types an activity may have. Distinct from ActivityType in that it has new types (e.g. MountainBikeRide)
			SportType *GetClubActivitiesById200SportType `json:"sport_type,omitempty"`

			// TotalElevationGain The activity's total elevation gain.
			TotalElevationGain *float32 `json:"total_elevation_gain,omitempty"`

			// Type Deprecated. Prefer to use sport_type
			Type *GetClubActivitiesById200Type `json:"type,omitempty"`

			// WorkoutType The activity's workout type
			WorkoutType *int `json:"workout_type,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			// Errors The set of specific errors associated with this fault, if any.
			Errors *[]struct {
				// Code The code associated with this error.
				Code *string `json:"code,omitempty"`

				// Field The specific field or aspect of the resource associated with this error.
				Field *string `json:"field,omitempty"`

				// Resource The type of resource associated with this error.
				Resource *string `json:"resource,omitempty"`
			} `json:"errors,omitempty"`

			// Message The message of the fault.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetClubMembersByIdResponse parses an HTTP response from a GetClubMembersByIdWithResponse call
func ParseGetClubMembersByIdResponse(rsp *http.Response) (*GetClubMembersByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClubMembersByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			// Admin Whether the athlete is a club admin.
			Admin *bool `json:"admin,omitempty"`

			// Firstname The athlete's first name.
			Firstname *string `json:"firstname,omitempty"`

			// Lastname The athlete's last initial.
			Lastname *string `json:"lastname,omitempty"`

			// Member The athlete's member status.
			Member *string `json:"member,omitempty"`

			// Owner Whether the athlete is club owner.
			Owner *bool `json:"owner,omitempty"`

			// ResourceState Resource state, indicates level of detail. Possible values: 1 -> "meta", 2 -> "summary", 3 -> "detail"
			ResourceState *int `json:"resource_state,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			// Errors The set of specific errors associated with this fault, if any.
			Errors *[]struct {
				// Code The code associated with this error.
				Code *string `json:"code,omitempty"`

				// Field The specific field or aspect of the resource associated with this error.
				Field *string `json:"field,omitempty"`

				// Resource The type of resource associated with this error.
				Resource *string `json:"resource,omitempty"`
			} `json:"errors,omitempty"`

			// Message The message of the fault.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetGearByIdResponse parses an HTTP response from a GetGearByIdWithResponse call
func ParseGetGearByIdResponse(rsp *http.Response) (*GetGearByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGearByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// BrandName The gear's brand name.
			BrandName *string `json:"brand_name,omitempty"`

			// Description The gear's description.
			Description *string `json:"description,omitempty"`

			// Distance The distance logged with this gear.
			Distance *float32 `json:"distance,omitempty"`

			// FrameType The gear's frame type (bike only).
			FrameType *int `json:"frame_type,omitempty"`

			// Id The gear's unique identifier.
			Id *string `json:"id,omitempty"`

			// ModelName The gear's model name.
			ModelName *string `json:"model_name,omitempty"`

			// Name The gear's name.
			Name *string `json:"name,omitempty"`

			// Primary Whether this gear's is the owner's default one.
			Primary *bool `json:"primary,omitempty"`

			// ResourceState Resource state, indicates level of detail. Possible values: 2 -> "summary", 3 -> "detail"
			ResourceState *int `json:"resource_state,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			// Errors The set of specific errors associated with this fault, if any.
			Errors *[]struct {
				// Code The code associated with this error.
				Code *string `json:"code,omitempty"`

				// Field The specific field or aspect of the resource associated with this error.
				Field *string `json:"field,omitempty"`

				// Resource The type of resource associated with this error.
				Resource *string `json:"resource,omitempty"`
			} `json:"errors,omitempty"`

			// Message The message of the fault.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetRouteByIdResponse parses an HTTP response from a GetRouteByIdWithResponse call
func ParseGetRouteByIdResponse(rsp *http.Response) (*GetRouteByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRouteByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Athlete *struct {
				// City The athlete's city.
				City *string `json:"city,omitempty"`

				// Country The athlete's country.
				Country *string `json:"country,omitempty"`

				// CreatedAt The time at which the athlete was created.
				CreatedAt *time.Time `json:"created_at,omitempty"`

				// Firstname The athlete's first name.
				Firstname *string `json:"firstname,omitempty"`

				// Id The unique identifier of the athlete
				Id *int64 `json:"id,omitempty"`

				// Lastname The athlete's last name.
				Lastname *string `json:"lastname,omitempty"`

				// Premium Deprecated.  Use summit field instead. Whether the athlete has any Summit subscription.
				Premium *bool `json:"premium,omitempty"`

				// Profile URL to a 124x124 pixel profile picture.
				Profile *string `json:"profile,omitempty"`

				// ProfileMedium URL to a 62x62 pixel profile picture.
				ProfileMedium *string `json:"profile_medium,omitempty"`

				// ResourceState Resource state, indicates level of detail. Possible values: 1 -> "meta", 2 -> "summary", 3 -> "detail"
				ResourceState *int `json:"resource_state,omitempty"`

				// Sex The athlete's sex.
				Sex *GetRouteById200AthleteSex `json:"sex,omitempty"`

				// State The athlete's state or geographical region.
				State *string `json:"state,omitempty"`

				// Summit Whether the athlete has any Summit subscription.
				Summit *bool `json:"summit,omitempty"`

				// UpdatedAt The time at which the athlete was last updated.
				UpdatedAt *time.Time `json:"updated_at,omitempty"`
			} `json:"athlete,omitempty"`

			// CreatedAt The time at which the route was created
			CreatedAt *time.Time `json:"created_at,omitempty"`

			// Description The description of the route
			Description *string `json:"description,omitempty"`

			// Distance The route's distance, in meters
			Distance *float32 `json:"distance,omitempty"`

			// ElevationGain The route's elevation gain.
			ElevationGain *float32 `json:"elevation_gain,omitempty"`

			// EstimatedMovingTime Estimated time in seconds for the authenticated athlete to complete route
			EstimatedMovingTime *int `json:"estimated_moving_time,omitempty"`

			// Id The unique identifier of this route
			Id *int64 `json:"id,omitempty"`

			// IdStr The unique identifier of the route in string format
			IdStr *string `json:"id_str,omitempty"`
			Map   *struct {
				// Id The identifier of the map
				Id *string `json:"id,omitempty"`

				// Polyline The polyline of the map, only returned on detailed representation of an object
				Polyline *string `json:"polyline,omitempty"`

				// SummaryPolyline The summary polyline of the map
				SummaryPolyline *string `json:"summary_polyline,omitempty"`
			} `json:"map,omitempty"`

			// Name The name of this route
			Name *string `json:"name,omitempty"`

			// Private Whether this route is private
			Private *bool `json:"private,omitempty"`

			// Segments The segments traversed by this route
			Segments *[]struct {
				ActivityType    *GetRouteById200SegmentsActivityType `json:"activity_type,omitempty"`
				AthletePrEffort *struct {
					// EffortCount Number of efforts by the authenticated athlete on this segment.
					EffortCount *int `json:"effort_count,omitempty"`

					// PrActivityId The unique identifier of the activity related to the PR effort.
					PrActivityId *int64 `json:"pr_activity_id,omitempty"`

					// PrDate The time at which the PR effort was started.
					PrDate *time.Time `json:"pr_date,omitempty"`

					// PrElapsedTime The elapsed time ot the PR effort.
					PrElapsedTime *int `json:"pr_elapsed_time,omitempty"`
				} `json:"athlete_pr_effort,omitempty"`
				AthleteSegmentStats *struct {
					// ActivityId The unique identifier of the activity related to this effort
					ActivityId *int64 `json:"activity_id,omitempty"`

					// Distance The effort's distance in meters
					Distance *float32 `json:"distance,omitempty"`

					// ElapsedTime The effort's elapsed time
					ElapsedTime *int `json:"elapsed_time,omitempty"`

					// Id The unique identifier of this effort
					Id *int64 `json:"id,omitempty"`

					// IsKom Whether this effort is the current best on the leaderboard
					IsKom *bool `json:"is_kom,omitempty"`

					// StartDate The time at which the effort was started.
					StartDate *time.Time `json:"start_date,omitempty"`

					// StartDateLocal The time at which the effort was started in the local timezone.
					StartDateLocal *time.Time `json:"start_date_local,omitempty"`
				} `json:"athlete_segment_stats,omitempty"`

				// AverageGrade The segment's average grade, in percents
				AverageGrade *float32 `json:"average_grade,omitempty"`

				// City The segments's city.
				City *string `json:"city,omitempty"`

				// ClimbCategory The category of the climb [0, 5]. Higher is harder ie. 5 is Hors catgorie, 0 is uncategorized in climb_category.
				ClimbCategory *int `json:"climb_category,omitempty"`

				// Country The segment's country.
				Country *string `json:"country,omitempty"`

				// Distance The segment's distance, in meters
				Distance *float32 `json:"distance,omitempty"`

				// ElevationHigh The segments's highest elevation, in meters
				ElevationHigh *float32 `json:"elevation_high,omitempty"`

				// ElevationLow The segments's lowest elevation, in meters
				ElevationLow *float32 `json:"elevation_low,omitempty"`

				// EndLatlng A pair of latitude/longitude coordinates, represented as an array of 2 floating point numbers.
				EndLatlng *[]float32 `json:"end_latlng,omitempty"`

				// Id The unique identifier of this segment
				Id *int64 `json:"id,omitempty"`

				// MaximumGrade The segments's maximum grade, in percents
				MaximumGrade *float32 `json:"maximum_grade,omitempty"`

				// Name The name of this segment
				Name *string `json:"name,omitempty"`

				// Private Whether this segment is private.
				Private *bool `json:"private,omitempty"`

				// StartLatlng A pair of latitude/longitude coordinates, represented as an array of 2 floating point numbers.
				StartLatlng *[]float32 `json:"start_latlng,omitempty"`

				// State The segments's state or geographical region.
				State *string `json:"state,omitempty"`
			} `json:"segments,omitempty"`

			// Starred Whether this route is starred by the logged-in athlete
			Starred *bool `json:"starred,omitempty"`

			// SubType This route's sub-type (1 for road, 2 for mountain bike, 3 for cross, 4 for trail, 5 for mixed)
			SubType *int `json:"sub_type,omitempty"`

			// Timestamp An epoch timestamp of when the route was created
			Timestamp *int `json:"timestamp,omitempty"`

			// Type This route's type (1 for ride, 2 for runs)
			Type *int `json:"type,omitempty"`

			// UpdatedAt The time at which the route was last updated
			UpdatedAt *time.Time `json:"updated_at,omitempty"`

			// Waypoints The custom waypoints along this route
			Waypoints *[]struct {
				// Categories Categories that the waypoint belongs to
				Categories *[]string `json:"categories,omitempty"`

				// Description A description of the waypoint (optional)
				Description *string `json:"description,omitempty"`

				// DistanceIntoRoute The number meters along the route that the waypoint is located
				DistanceIntoRoute *float32 `json:"distance_into_route,omitempty"`

				// Latlng The location along the route that the waypoint is closest to
				Latlng *[]float32 `json:"latlng,omitempty"`

				// TargetLatlng A location off of the route that the waypoint is (optional)
				TargetLatlng *[]float32 `json:"target_latlng,omitempty"`

				// Title A title for the waypoint
				Title *string `json:"title,omitempty"`
			} `json:"waypoints,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			// Errors The set of specific errors associated with this fault, if any.
			Errors *[]struct {
				// Code The code associated with this error.
				Code *string `json:"code,omitempty"`

				// Field The specific field or aspect of the resource associated with this error.
				Field *string `json:"field,omitempty"`

				// Resource The type of resource associated with this error.
				Resource *string `json:"resource,omitempty"`
			} `json:"errors,omitempty"`

			// Message The message of the fault.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetEffortsBySegmentIdResponse parses an HTTP response from a GetEffortsBySegmentIdWithResponse call
func ParseGetEffortsBySegmentIdResponse(rsp *http.Response) (*GetEffortsBySegmentIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEffortsBySegmentIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			Activity *struct {
				// Id The unique identifier of the activity
				Id *int64 `json:"id,omitempty"`
			} `json:"activity,omitempty"`

			// ActivityId The unique identifier of the activity related to this effort
			ActivityId *int64 `json:"activity_id,omitempty"`
			Athlete    *struct {
				// Id The unique identifier of the athlete
				Id *int64 `json:"id,omitempty"`
			} `json:"athlete,omitempty"`

			// AverageCadence The effort's average cadence
			AverageCadence *float32 `json:"average_cadence,omitempty"`

			// AverageHeartrate The heart heart rate of the athlete during this effort
			AverageHeartrate *float32 `json:"average_heartrate,omitempty"`

			// AverageWatts The average wattage of this effort
			AverageWatts *float32 `json:"average_watts,omitempty"`

			// DeviceWatts For riding efforts, whether the wattage was reported by a dedicated recording device
			DeviceWatts *bool `json:"device_watts,omitempty"`

			// Distance The effort's distance in meters
			Distance *float32 `json:"distance,omitempty"`

			// ElapsedTime The effort's elapsed time
			ElapsedTime *int `json:"elapsed_time,omitempty"`

			// EndIndex The end index of this effort in its activity's stream
			EndIndex *int `json:"end_index,omitempty"`

			// Hidden Whether this effort should be hidden when viewed within an activity
			Hidden *bool `json:"hidden,omitempty"`

			// Id The unique identifier of this effort
			Id *int64 `json:"id,omitempty"`

			// IsKom Whether this effort is the current best on the leaderboard
			IsKom *bool `json:"is_kom,omitempty"`

			// KomRank The rank of the effort on the global leaderboard if it belongs in the top 10 at the time of upload
			KomRank *int `json:"kom_rank,omitempty"`

			// MaxHeartrate The maximum heart rate of the athlete during this effort
			MaxHeartrate *float32 `json:"max_heartrate,omitempty"`

			// MovingTime The effort's moving time
			MovingTime *int `json:"moving_time,omitempty"`

			// Name The name of the segment on which this effort was performed
			Name *string `json:"name,omitempty"`

			// PrRank The rank of the effort on the athlete's leaderboard if it belongs in the top 3 at the time of upload
			PrRank  *int `json:"pr_rank,omitempty"`
			Segment *struct {
				ActivityType    *GetEffortsBySegmentId200SegmentActivityType `json:"activity_type,omitempty"`
				AthletePrEffort *struct {
					// EffortCount Number of efforts by the authenticated athlete on this segment.
					EffortCount *int `json:"effort_count,omitempty"`

					// PrActivityId The unique identifier of the activity related to the PR effort.
					PrActivityId *int64 `json:"pr_activity_id,omitempty"`

					// PrDate The time at which the PR effort was started.
					PrDate *time.Time `json:"pr_date,omitempty"`

					// PrElapsedTime The elapsed time ot the PR effort.
					PrElapsedTime *int `json:"pr_elapsed_time,omitempty"`
				} `json:"athlete_pr_effort,omitempty"`
				AthleteSegmentStats *struct {
					// ActivityId The unique identifier of the activity related to this effort
					ActivityId *int64 `json:"activity_id,omitempty"`

					// Distance The effort's distance in meters
					Distance *float32 `json:"distance,omitempty"`

					// ElapsedTime The effort's elapsed time
					ElapsedTime *int `json:"elapsed_time,omitempty"`

					// Id The unique identifier of this effort
					Id *int64 `json:"id,omitempty"`

					// IsKom Whether this effort is the current best on the leaderboard
					IsKom *bool `json:"is_kom,omitempty"`

					// StartDate The time at which the effort was started.
					StartDate *time.Time `json:"start_date,omitempty"`

					// StartDateLocal The time at which the effort was started in the local timezone.
					StartDateLocal *time.Time `json:"start_date_local,omitempty"`
				} `json:"athlete_segment_stats,omitempty"`

				// AverageGrade The segment's average grade, in percents
				AverageGrade *float32 `json:"average_grade,omitempty"`

				// City The segments's city.
				City *string `json:"city,omitempty"`

				// ClimbCategory The category of the climb [0, 5]. Higher is harder ie. 5 is Hors catgorie, 0 is uncategorized in climb_category.
				ClimbCategory *int `json:"climb_category,omitempty"`

				// Country The segment's country.
				Country *string `json:"country,omitempty"`

				// Distance The segment's distance, in meters
				Distance *float32 `json:"distance,omitempty"`

				// ElevationHigh The segments's highest elevation, in meters
				ElevationHigh *float32 `json:"elevation_high,omitempty"`

				// ElevationLow The segments's lowest elevation, in meters
				ElevationLow *float32 `json:"elevation_low,omitempty"`

				// EndLatlng A pair of latitude/longitude coordinates, represented as an array of 2 floating point numbers.
				EndLatlng *[]float32 `json:"end_latlng,omitempty"`

				// Id The unique identifier of this segment
				Id *int64 `json:"id,omitempty"`

				// MaximumGrade The segments's maximum grade, in percents
				MaximumGrade *float32 `json:"maximum_grade,omitempty"`

				// Name The name of this segment
				Name *string `json:"name,omitempty"`

				// Private Whether this segment is private.
				Private *bool `json:"private,omitempty"`

				// StartLatlng A pair of latitude/longitude coordinates, represented as an array of 2 floating point numbers.
				StartLatlng *[]float32 `json:"start_latlng,omitempty"`

				// State The segments's state or geographical region.
				State *string `json:"state,omitempty"`
			} `json:"segment,omitempty"`

			// StartDate The time at which the effort was started.
			StartDate *time.Time `json:"start_date,omitempty"`

			// StartDateLocal The time at which the effort was started in the local timezone.
			StartDateLocal *time.Time `json:"start_date_local,omitempty"`

			// StartIndex The start index of this effort in its activity's stream
			StartIndex *int `json:"start_index,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			// Errors The set of specific errors associated with this fault, if any.
			Errors *[]struct {
				// Code The code associated with this error.
				Code *string `json:"code,omitempty"`

				// Field The specific field or aspect of the resource associated with this error.
				Field *string `json:"field,omitempty"`

				// Resource The type of resource associated with this error.
				Resource *string `json:"resource,omitempty"`
			} `json:"errors,omitempty"`

			// Message The message of the fault.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetSegmentEffortByIdResponse parses an HTTP response from a GetSegmentEffortByIdWithResponse call
func ParseGetSegmentEffortByIdResponse(rsp *http.Response) (*GetSegmentEffortByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSegmentEffortByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Activity *struct {
				// Id The unique identifier of the activity
				Id *int64 `json:"id,omitempty"`
			} `json:"activity,omitempty"`

			// ActivityId The unique identifier of the activity related to this effort
			ActivityId *int64 `json:"activity_id,omitempty"`
			Athlete    *struct {
				// Id The unique identifier of the athlete
				Id *int64 `json:"id,omitempty"`
			} `json:"athlete,omitempty"`

			// AverageCadence The effort's average cadence
			AverageCadence *float32 `json:"average_cadence,omitempty"`

			// AverageHeartrate The heart heart rate of the athlete during this effort
			AverageHeartrate *float32 `json:"average_heartrate,omitempty"`

			// AverageWatts The average wattage of this effort
			AverageWatts *float32 `json:"average_watts,omitempty"`

			// DeviceWatts For riding efforts, whether the wattage was reported by a dedicated recording device
			DeviceWatts *bool `json:"device_watts,omitempty"`

			// Distance The effort's distance in meters
			Distance *float32 `json:"distance,omitempty"`

			// ElapsedTime The effort's elapsed time
			ElapsedTime *int `json:"elapsed_time,omitempty"`

			// EndIndex The end index of this effort in its activity's stream
			EndIndex *int `json:"end_index,omitempty"`

			// Hidden Whether this effort should be hidden when viewed within an activity
			Hidden *bool `json:"hidden,omitempty"`

			// Id The unique identifier of this effort
			Id *int64 `json:"id,omitempty"`

			// IsKom Whether this effort is the current best on the leaderboard
			IsKom *bool `json:"is_kom,omitempty"`

			// KomRank The rank of the effort on the global leaderboard if it belongs in the top 10 at the time of upload
			KomRank *int `json:"kom_rank,omitempty"`

			// MaxHeartrate The maximum heart rate of the athlete during this effort
			MaxHeartrate *float32 `json:"max_heartrate,omitempty"`

			// MovingTime The effort's moving time
			MovingTime *int `json:"moving_time,omitempty"`

			// Name The name of the segment on which this effort was performed
			Name *string `json:"name,omitempty"`

			// PrRank The rank of the effort on the athlete's leaderboard if it belongs in the top 3 at the time of upload
			PrRank  *int `json:"pr_rank,omitempty"`
			Segment *struct {
				ActivityType    *GetSegmentEffortById200SegmentActivityType `json:"activity_type,omitempty"`
				AthletePrEffort *struct {
					// EffortCount Number of efforts by the authenticated athlete on this segment.
					EffortCount *int `json:"effort_count,omitempty"`

					// PrActivityId The unique identifier of the activity related to the PR effort.
					PrActivityId *int64 `json:"pr_activity_id,omitempty"`

					// PrDate The time at which the PR effort was started.
					PrDate *time.Time `json:"pr_date,omitempty"`

					// PrElapsedTime The elapsed time ot the PR effort.
					PrElapsedTime *int `json:"pr_elapsed_time,omitempty"`
				} `json:"athlete_pr_effort,omitempty"`
				AthleteSegmentStats *struct {
					// ActivityId The unique identifier of the activity related to this effort
					ActivityId *int64 `json:"activity_id,omitempty"`

					// Distance The effort's distance in meters
					Distance *float32 `json:"distance,omitempty"`

					// ElapsedTime The effort's elapsed time
					ElapsedTime *int `json:"elapsed_time,omitempty"`

					// Id The unique identifier of this effort
					Id *int64 `json:"id,omitempty"`

					// IsKom Whether this effort is the current best on the leaderboard
					IsKom *bool `json:"is_kom,omitempty"`

					// StartDate The time at which the effort was started.
					StartDate *time.Time `json:"start_date,omitempty"`

					// StartDateLocal The time at which the effort was started in the local timezone.
					StartDateLocal *time.Time `json:"start_date_local,omitempty"`
				} `json:"athlete_segment_stats,omitempty"`

				// AverageGrade The segment's average grade, in percents
				AverageGrade *float32 `json:"average_grade,omitempty"`

				// City The segments's city.
				City *string `json:"city,omitempty"`

				// ClimbCategory The category of the climb [0, 5]. Higher is harder ie. 5 is Hors catgorie, 0 is uncategorized in climb_category.
				ClimbCategory *int `json:"climb_category,omitempty"`

				// Country The segment's country.
				Country *string `json:"country,omitempty"`

				// Distance The segment's distance, in meters
				Distance *float32 `json:"distance,omitempty"`

				// ElevationHigh The segments's highest elevation, in meters
				ElevationHigh *float32 `json:"elevation_high,omitempty"`

				// ElevationLow The segments's lowest elevation, in meters
				ElevationLow *float32 `json:"elevation_low,omitempty"`

				// EndLatlng A pair of latitude/longitude coordinates, represented as an array of 2 floating point numbers.
				EndLatlng *[]float32 `json:"end_latlng,omitempty"`

				// Id The unique identifier of this segment
				Id *int64 `json:"id,omitempty"`

				// MaximumGrade The segments's maximum grade, in percents
				MaximumGrade *float32 `json:"maximum_grade,omitempty"`

				// Name The name of this segment
				Name *string `json:"name,omitempty"`

				// Private Whether this segment is private.
				Private *bool `json:"private,omitempty"`

				// StartLatlng A pair of latitude/longitude coordinates, represented as an array of 2 floating point numbers.
				StartLatlng *[]float32 `json:"start_latlng,omitempty"`

				// State The segments's state or geographical region.
				State *string `json:"state,omitempty"`
			} `json:"segment,omitempty"`

			// StartDate The time at which the effort was started.
			StartDate *time.Time `json:"start_date,omitempty"`

			// StartDateLocal The time at which the effort was started in the local timezone.
			StartDateLocal *time.Time `json:"start_date_local,omitempty"`

			// StartIndex The start index of this effort in its activity's stream
			StartIndex *int `json:"start_index,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			// Errors The set of specific errors associated with this fault, if any.
			Errors *[]struct {
				// Code The code associated with this error.
				Code *string `json:"code,omitempty"`

				// Field The specific field or aspect of the resource associated with this error.
				Field *string `json:"field,omitempty"`

				// Resource The type of resource associated with this error.
				Resource *string `json:"resource,omitempty"`
			} `json:"errors,omitempty"`

			// Message The message of the fault.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseExploreSegmentsResponse parses an HTTP response from a ExploreSegmentsWithResponse call
func ParseExploreSegmentsResponse(rsp *http.Response) (*ExploreSegmentsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExploreSegmentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Segments The set of segments matching an explorer request
			Segments *[]struct {
				// AvgGrade The segment's average grade, in percents
				AvgGrade *float32 `json:"avg_grade,omitempty"`

				// ClimbCategory The category of the climb [0, 5]. Higher is harder ie. 5 is Hors catgorie, 0 is uncategorized in climb_category. If climb_category = 5, climb_category_desc = HC. If climb_category = 2, climb_category_desc = 3.
				ClimbCategory *int `json:"climb_category,omitempty"`

				// ClimbCategoryDesc The description for the category of the climb
				ClimbCategoryDesc *ExploreSegments200SegmentsClimbCategoryDesc `json:"climb_category_desc,omitempty"`

				// Distance The segment's distance, in meters
				Distance *float32 `json:"distance,omitempty"`

				// ElevDifference The segments's evelation difference, in meters
				ElevDifference *float32 `json:"elev_difference,omitempty"`

				// EndLatlng A pair of latitude/longitude coordinates, represented as an array of 2 floating point numbers.
				EndLatlng *[]float32 `json:"end_latlng,omitempty"`

				// Id The unique identifier of this segment
				Id *int64 `json:"id,omitempty"`

				// Name The name of this segment
				Name *string `json:"name,omitempty"`

				// Points The polyline of the segment
				Points *string `json:"points,omitempty"`

				// StartLatlng A pair of latitude/longitude coordinates, represented as an array of 2 floating point numbers.
				StartLatlng *[]float32 `json:"start_latlng,omitempty"`
			} `json:"segments,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			// Errors The set of specific errors associated with this fault, if any.
			Errors *[]struct {
				// Code The code associated with this error.
				Code *string `json:"code,omitempty"`

				// Field The specific field or aspect of the resource associated with this error.
				Field *string `json:"field,omitempty"`

				// Resource The type of resource associated with this error.
				Resource *string `json:"resource,omitempty"`
			} `json:"errors,omitempty"`

			// Message The message of the fault.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetLoggedInAthleteStarredSegmentsResponse parses an HTTP response from a GetLoggedInAthleteStarredSegmentsWithResponse call
func ParseGetLoggedInAthleteStarredSegmentsResponse(rsp *http.Response) (*GetLoggedInAthleteStarredSegmentsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLoggedInAthleteStarredSegmentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			ActivityType    *GetLoggedInAthleteStarredSegments200ActivityType `json:"activity_type,omitempty"`
			AthletePrEffort *struct {
				// EffortCount Number of efforts by the authenticated athlete on this segment.
				EffortCount *int `json:"effort_count,omitempty"`

				// PrActivityId The unique identifier of the activity related to the PR effort.
				PrActivityId *int64 `json:"pr_activity_id,omitempty"`

				// PrDate The time at which the PR effort was started.
				PrDate *time.Time `json:"pr_date,omitempty"`

				// PrElapsedTime The elapsed time ot the PR effort.
				PrElapsedTime *int `json:"pr_elapsed_time,omitempty"`
			} `json:"athlete_pr_effort,omitempty"`
			AthleteSegmentStats *struct {
				// ActivityId The unique identifier of the activity related to this effort
				ActivityId *int64 `json:"activity_id,omitempty"`

				// Distance The effort's distance in meters
				Distance *float32 `json:"distance,omitempty"`

				// ElapsedTime The effort's elapsed time
				ElapsedTime *int `json:"elapsed_time,omitempty"`

				// Id The unique identifier of this effort
				Id *int64 `json:"id,omitempty"`

				// IsKom Whether this effort is the current best on the leaderboard
				IsKom *bool `json:"is_kom,omitempty"`

				// StartDate The time at which the effort was started.
				StartDate *time.Time `json:"start_date,omitempty"`

				// StartDateLocal The time at which the effort was started in the local timezone.
				StartDateLocal *time.Time `json:"start_date_local,omitempty"`
			} `json:"athlete_segment_stats,omitempty"`

			// AverageGrade The segment's average grade, in percents
			AverageGrade *float32 `json:"average_grade,omitempty"`

			// City The segments's city.
			City *string `json:"city,omitempty"`

			// ClimbCategory The category of the climb [0, 5]. Higher is harder ie. 5 is Hors catgorie, 0 is uncategorized in climb_category.
			ClimbCategory *int `json:"climb_category,omitempty"`

			// Country The segment's country.
			Country *string `json:"country,omitempty"`

			// Distance The segment's distance, in meters
			Distance *float32 `json:"distance,omitempty"`

			// ElevationHigh The segments's highest elevation, in meters
			ElevationHigh *float32 `json:"elevation_high,omitempty"`

			// ElevationLow The segments's lowest elevation, in meters
			ElevationLow *float32 `json:"elevation_low,omitempty"`

			// EndLatlng A pair of latitude/longitude coordinates, represented as an array of 2 floating point numbers.
			EndLatlng *[]float32 `json:"end_latlng,omitempty"`

			// Id The unique identifier of this segment
			Id *int64 `json:"id,omitempty"`

			// MaximumGrade The segments's maximum grade, in percents
			MaximumGrade *float32 `json:"maximum_grade,omitempty"`

			// Name The name of this segment
			Name *string `json:"name,omitempty"`

			// Private Whether this segment is private.
			Private *bool `json:"private,omitempty"`

			// StartLatlng A pair of latitude/longitude coordinates, represented as an array of 2 floating point numbers.
			StartLatlng *[]float32 `json:"start_latlng,omitempty"`

			// State The segments's state or geographical region.
			State *string `json:"state,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			// Errors The set of specific errors associated with this fault, if any.
			Errors *[]struct {
				// Code The code associated with this error.
				Code *string `json:"code,omitempty"`

				// Field The specific field or aspect of the resource associated with this error.
				Field *string `json:"field,omitempty"`

				// Resource The type of resource associated with this error.
				Resource *string `json:"resource,omitempty"`
			} `json:"errors,omitempty"`

			// Message The message of the fault.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetSegmentByIdResponse parses an HTTP response from a GetSegmentByIdWithResponse call
func ParseGetSegmentByIdResponse(rsp *http.Response) (*GetSegmentByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSegmentByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			ActivityType *GetSegmentById200ActivityType `json:"activity_type,omitempty"`

			// AthleteCount The number of unique athletes who have an effort for this segment
			AthleteCount    *int `json:"athlete_count,omitempty"`
			AthletePrEffort *struct {
				// EffortCount Number of efforts by the authenticated athlete on this segment.
				EffortCount *int `json:"effort_count,omitempty"`

				// PrActivityId The unique identifier of the activity related to the PR effort.
				PrActivityId *int64 `json:"pr_activity_id,omitempty"`

				// PrDate The time at which the PR effort was started.
				PrDate *time.Time `json:"pr_date,omitempty"`

				// PrElapsedTime The elapsed time ot the PR effort.
				PrElapsedTime *int `json:"pr_elapsed_time,omitempty"`
			} `json:"athlete_pr_effort,omitempty"`
			AthleteSegmentStats *struct {
				// ActivityId The unique identifier of the activity related to this effort
				ActivityId *int64 `json:"activity_id,omitempty"`

				// Distance The effort's distance in meters
				Distance *float32 `json:"distance,omitempty"`

				// ElapsedTime The effort's elapsed time
				ElapsedTime *int `json:"elapsed_time,omitempty"`

				// Id The unique identifier of this effort
				Id *int64 `json:"id,omitempty"`

				// IsKom Whether this effort is the current best on the leaderboard
				IsKom *bool `json:"is_kom,omitempty"`

				// StartDate The time at which the effort was started.
				StartDate *time.Time `json:"start_date,omitempty"`

				// StartDateLocal The time at which the effort was started in the local timezone.
				StartDateLocal *time.Time `json:"start_date_local,omitempty"`
			} `json:"athlete_segment_stats,omitempty"`

			// AverageGrade The segment's average grade, in percents
			AverageGrade *float32 `json:"average_grade,omitempty"`

			// City The segments's city.
			City *string `json:"city,omitempty"`

			// ClimbCategory The category of the climb [0, 5]. Higher is harder ie. 5 is Hors catgorie, 0 is uncategorized in climb_category.
			ClimbCategory *int `json:"climb_category,omitempty"`

			// Country The segment's country.
			Country *string `json:"country,omitempty"`

			// CreatedAt The time at which the segment was created.
			CreatedAt *time.Time `json:"created_at,omitempty"`

			// Distance The segment's distance, in meters
			Distance *float32 `json:"distance,omitempty"`

			// EffortCount The total number of efforts for this segment
			EffortCount *int `json:"effort_count,omitempty"`

			// ElevationHigh The segments's highest elevation, in meters
			ElevationHigh *float32 `json:"elevation_high,omitempty"`

			// ElevationLow The segments's lowest elevation, in meters
			ElevationLow *float32 `json:"elevation_low,omitempty"`

			// EndLatlng A pair of latitude/longitude coordinates, represented as an array of 2 floating point numbers.
			EndLatlng *[]float32 `json:"end_latlng,omitempty"`

			// Hazardous Whether this segment is considered hazardous
			Hazardous *bool `json:"hazardous,omitempty"`

			// Id The unique identifier of this segment
			Id  *int64 `json:"id,omitempty"`
			Map *struct {
				// Id The identifier of the map
				Id *string `json:"id,omitempty"`

				// Polyline The polyline of the map, only returned on detailed representation of an object
				Polyline *string `json:"polyline,omitempty"`

				// SummaryPolyline The summary polyline of the map
				SummaryPolyline *string `json:"summary_polyline,omitempty"`
			} `json:"map,omitempty"`

			// MaximumGrade The segments's maximum grade, in percents
			MaximumGrade *float32 `json:"maximum_grade,omitempty"`

			// Name The name of this segment
			Name *string `json:"name,omitempty"`

			// Private Whether this segment is private.
			Private *bool `json:"private,omitempty"`

			// StarCount The number of stars for this segment
			StarCount *int `json:"star_count,omitempty"`

			// StartLatlng A pair of latitude/longitude coordinates, represented as an array of 2 floating point numbers.
			StartLatlng *[]float32 `json:"start_latlng,omitempty"`

			// State The segments's state or geographical region.
			State *string `json:"state,omitempty"`

			// TotalElevationGain The segment's total elevation gain.
			TotalElevationGain *float32 `json:"total_elevation_gain,omitempty"`

			// UpdatedAt The time at which the segment was last updated.
			UpdatedAt *time.Time `json:"updated_at,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest struct {
			// Errors The set of specific errors associated with this fault, if any.
			Errors *[]struct {
				// Code The code associated with this error.
				Code *string `json:"code,omitempty"`

				// Field The specific field or aspect of the resource associated with this error.
				Field *string `json:"field,omitempty"`

				// Resource The type of resource associated with this error.
				Resource *string `json:"resource,omitempty"`
			} `json:"errors,omitempty"`

			// Message The message of the fault.
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}
